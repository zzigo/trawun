
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>trawun v1.2.0</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel="stylesheet">
  <script src="parsers/commandParser.js"></script>
  <script src="generators/sineGenerator.js"></script>

  <style>
    body {
      margin: 0;
      font-family: 'IBM Plex Mono', monospace;
      overflow: hidden;
    }
    .vumeter {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 3;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 2;
      text-align: left;
    }
    button {
      padding: 10px;
      margin: 5px;
      font-family: 'IBM Plex Mono', monospace;
      background: rgba(0, 0, 0, 0.7);
      color: #00ff00;
      border: 1px solid #00ff00;
      cursor: pointer;
      touch-action: manipulation;
    }
    #hud {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #00ff00;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 14px;
      padding: 10px;
      z-index: 2;
      max-width: 400px;
      white-space: pre;
      text-transform: lowercase;
    }
    #performers-hud {
      position: fixed; /* Fixed position to ensure it stays in view */
      top: 10px;
      right: 10px;
      font-family: 'IBM Plex Mono', monospace;
      color: #00ff00;
      text-align: right;
      font-size: 14px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      z-index: 9999; /* Very high z-index to ensure it's above everything */
      pointer-events: auto; /* Ensure clicks go through */
      white-space: pre;
      text-transform: lowercase;
      max-width: 400px;
    }
    
    /* Make the version link more clickable */
    .version-link {
      position: relative;
      display: inline-block;
      padding: 5px 8px;
      margin-bottom: 6px;
      background-color: rgba(0,0,0,0.6); /* Dark background for visibility */
      color: #c8a2c8; /* Keep the purple color */
      border-radius: 4px;
      cursor: pointer;
      z-index: 10000; /* Even higher z-index */
      pointer-events: auto;
      border: 1px solid rgba(200, 162, 200, 0.3); /* Subtle border */
    }
    
    .version-link:hover {
      background-color: rgba(20, 20, 20, 0.8);
      color: #ffffff;
    }
    #commandPrompt {
      width: 100%;
      padding: 5px;
      margin-top: 10px;
      background: rgba(200, 162, 200, 0.2); /* lilac */
      color: #4169e1; /* blue */
      border: 1px solid #4169e1;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 14px;
      z-index: 9999; /* Ensure prompt is always on top */
      position: relative; /* Required for z-index to work */
    }
    #commandPrompt:focus {
      outline: none;
      border-color: #c8a2c8;
      background: rgba(200, 162, 200, 0.4); /* Stronger background when focused */
    }
    
    /* Visual indicator when prompt is ready for input */
    #commandPrompt.ready {
      animation: pulse-border 2s infinite;
    }
    
    @keyframes pulse-border {
      0% { border-color: #4169e1; }
      50% { border-color: #c8a2c8; }
      100% { border-color: #4169e1; }
    }
    input:focus {
      outline: none;
      animation: pulse 2s infinite;
    }
    
    /* Fix for command prompt to ensure it's always accessible */
    #commandPrompt {
      position: relative;
      z-index: 9990; /* Very high z-index */
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
    }
    
    #commandPrompt.ready {
      z-index: 10001; /* Even higher when in ready state */
    }
    
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(200, 162, 200, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(200, 162, 200, 0); }
      100% { box-shadow: 0 0 0 0 rgba(200, 162, 200, 0); }
    }
    /* Modal dialog styles */
    .modal-overlay {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.8);
      transition: opacity 0.3s ease;
    }
    
    .modal-content {
      position: relative;
      background-color: rgba(0,0,0,0.9);
      color: #00ff00;
      margin: 5% auto;
      padding: 20px;
      border: 1px solid #00ff00;
      width: 85%;
      max-width: 900px;
      max-height: 80vh;
      overflow-y: auto;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 14px;
    }
    
    .modal-close {
      color: #00ff00;
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    
    .modal-content h1 {
      color: #00ff00;
      font-size: 24px;
      margin-bottom: 20px;
      border-bottom: 1px solid #00ff00;
      padding-bottom: 10px;
    }
    
    .modal-content h2 {
      color: #00ff00;
      font-size: 20px;
      margin-top: 20px;
      margin-bottom: 10px;
    }
    
    .modal-content h3 {
      color: #00ff00;
      font-size: 16px;
      margin-top: 15px;
      margin-bottom: 8px;
    }
    
    .modal-content pre {
      background-color: rgba(0,0,0,0.5);
      border: 1px solid #2a2a2a;
      padding: 10px;
      overflow-x: auto;
      color: #ffffff;
    }
    
    .modal-content code {
      font-family: 'IBM Plex Mono', monospace;
      color: #c8a2c8;
    }
    
    .version-link {
      color: #c8a2c8;
      text-decoration: none;
      cursor: pointer;
      font-size: 12px;
      opacity: 0.7;
      transition: opacity 0.2s ease;
    }
    
    .version-link:hover {
      opacity: 1;
      text-decoration: underline;
    }
    
    /* Quick reference section for essential commands */
    .quick-reference {
      margin-bottom: 20px;
      padding: 10px;
      background-color: rgba(200, 162, 200, 0.1);
      border-left: 3px solid #c8a2c8;
    }
    
    .keyboard-shortcuts {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px 15px;
    }
    
    .keyboard-shortcut-key {
      background-color: rgba(0,0,0,0.5);
      border: 1px solid #555;
      border-radius: 3px;
      padding: 2px 5px;
      display: inline-block;
      margin-right: 5px;
      font-size: 12px;
    }
    
    #console {
      max-height: 100px;
      overflow-y: auto;
      margin-top: 10px;
      font-size: 12px;
      color: #D4A5A5; /* soft pink */
    }
    .client-data {
      opacity: 0.3;
    }
    #requestConductor {
      position: absolute;
      left: 0;
    }
     #commandPrompt {
      width: 100%;
      padding: 5px;
      margin-top: 10px;
      background: none;
      color: #8fedf0; /* Blue */
      border: 0px none;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 14px;
    }
</style>
</head>
<body>
  <!-- README Modal -->
  <div id="readmeModal" class="modal-overlay">
    <div class="modal-content">
      <span class="modal-close" onclick="closeReadmeModal()">&times;</span>
      <h1>trawun v1.2.0</h1>
      
      <!-- Quick Reference Section -->
      <div class="quick-reference">
        <h2>Essential Generators</h2>
        <ul>
          <li><code>s440</code> - Sine wave at 440 Hz</li>
          <li><code>s440^2</code> - Sine wave at 440 Hz for 2 seconds</li>
          <li><code>s440v5</code> - Sine wave with volume 0.5</li>
          <li><code>sf100-500</code> - Sine fade cloud between 100-500 Hz</li>
          <li><code>sf100-500^1*5v1</code> - 5 sine tones between 100-500 Hz, 1 sec each</li>
          <li><code>n1^3</code> - Grey noise for 3 seconds</li>
        </ul>
        
        <h2>Keyboard Shortcuts</h2>
        <div class="keyboard-shortcuts">
          <div><span class="keyboard-shortcut-key">i</span></div>
          <div>Focus command prompt</div>
          
          <div><span class="keyboard-shortcut-key">Space</span></div>
          <div>Focus prompt for command chaining</div>
          
          <div><span class="keyboard-shortcut-key">Shift</span>+<span class="keyboard-shortcut-key">Enter</span></div>
          <div>Execute command and keep prompt focused</div>
          
          <div><span class="keyboard-shortcut-key">Tab</span></div>
          <div>Quick command chaining with previous frequency</div>
          
          <div><span class="keyboard-shortcut-key">Ctrl</span>+<span class="keyboard-shortcut-key">X</span></div>
          <div>Panic stop (all sounds)</div>
          
          <div><span class="keyboard-shortcut-key">Ctrl</span>+<span class="keyboard-shortcut-key">F</span></div>
          <div>Panic fade out (6 seconds)</div>
          
          <div><span class="keyboard-shortcut-key">Ctrl</span>+<span class="keyboard-shortcut-key">Shift</span>+<span class="keyboard-shortcut-key">H</span></div>
          <div>Toggle HUD visibility</div>
          
          <div><span class="keyboard-shortcut-key">Double-click</span></div>
          <div>Toggle fullscreen mode</div>
        </div>
      </div>
      
      <!-- Full README content will be loaded here -->
      <div id="readmeContent"></div>
    </div>
  </div>
  
  <!-- Audio overlay moved to a single instance below -->
  <div id="controls">
    <div id="conductorControls" style="display:none;">
    </div>
    <!-- Transparent Start Audio Overlay (with QR placeholder) -->
    <div id="startAudioOverlay" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1000;background:#000;display:flex;align-items:center;justify-content:center;cursor:pointer;" onclick="document.getElementById('startAudioOverlay').style.display = 'none'; startAudio();">
  <div style="display:flex;flex-direction:column;align-items:center;">
    <img src="qr.png" alt="QR code" style="width:180px;height:180px;object-fit:contain;margin-bottom:24px;filter:drop-shadow(0 0 8px #fff);background:#fff;border-radius:16px;" />
    <span style="color:#fff;font-size:24px;">tap anywhere to start audio</span>
  </div>
</div>
  </div>
  <div id="hud">initializing...</div>
  <div id="performers-hud"></div>
  <script>
// ---- Inlined SineCirclePhysics ----
class SineCirclePhysics {
  constructor(baseRadius = 60) {
    this.N = 120;
    this.baseRadius = baseRadius;
    this.center = { x: 0, y: 0 };
    this.modes = [];
    this.electricModes = [];
    this.t = 0;
    this.perturbationIndex = 0.1; // 0 = none, 1 = max
    this.startTime = null;
    this.envAmt = 0;
    this.decayAmt = 0;
    this._initModes();
  }
  _initModes() {
    let modeNumbers = [2, 3, 5, 6];
    for (let n of modeNumbers) {
      this.modes.push({
        n,
        baseAmp: 0,
        amp: 0,
        phase: Math.random() * Math.PI * 2,
        speed: Math.random() * 2 + 1.5
      });
    }
    let electricNumbers = [13, 17, 23];
    for (let n of electricNumbers) {
      this.electricModes.push({
        n,
        amp: 0.8,
        speed: Math.random() * 15 + 15,
        phase: Math.random() * Math.PI * 2
      });
    }
  }
  trigger(nowMillis) {
    this.startTime = nowMillis || (typeof millis === 'function' ? millis() : Date.now());
    for (let m of this.modes) {
      m.baseAmp = Math.random() * 10 + 5;
      m.phase = Math.random() * Math.PI * 2;
    }
    for (let em of this.electricModes) {
      em.phase = Math.random() * Math.PI * 2;
    }
  }
  update(nowMillis) {
    this.t += 0.04;
    if (this.startTime !== null) {
      let elapsed = (nowMillis || (typeof millis === 'function' ? millis() : Date.now())) - this.startTime;
      if (elapsed < 300) {
        let pct = Math.max(0, Math.min(1, elapsed / 300));
        this.envAmt = Math.pow(pct, 2.2);
      } else if (elapsed < 500) {
        this.envAmt = 1;
      } else if (elapsed < 1000) {
        this.envAmt = this._map(elapsed, 500, 1000, 1, 0);
      } else {
        this.envAmt = 0;
      }
      this.decayAmt = Math.exp(-0.0025 * elapsed);
    } else {
      this.envAmt = 0;
      this.decayAmt = 0;
    }
  }
  getShapePoints(centerX, centerY) {
    let points = [];
    for (let i = 0; i < this.N; i++) {
      let angle = (Math.PI * 2) * i / this.N;
      let r = this.baseRadius;
      for (let m of this.modes) {
        let jitter = Math.sin(m.n * angle + m.phase + this.t * m.speed);
        let amp = m.baseAmp * (0.4 * this.envAmt + 0.6 * this.decayAmt);
        r += amp * this.perturbationIndex * jitter;
      }
      for (let em of this.electricModes) {
        let buzz = Math.sin(em.n * angle + em.phase + this.t * em.speed);
        r += buzz * em.amp * this.envAmt * this.perturbationIndex;
      }
      let x = centerX + r * Math.cos(angle);
      let y = centerY + r * Math.sin(angle);
      points.push({ x, y });
    }
    return points;
  }
  _map(val, a, b, c, d) {
    return c + (d - c) * ((val - a) / (b - a));
  }
}
// ---- End Inlined SineCirclePhysics ----
    let socket = io();
    let synth = null;
let meterAnalyser = null;
let meterDataArray = null;
let meterLevel = 0;
    let clientId, clientName, role, clients = {};
    // Version tracking
    const TRAWUN_VERSION = '1.2.0';
    
    let audioStarted = false;
    let lastCommand = null;
    let lastCommandExecuted = null; // Track last executed command for chaining
    let commandHistory = [];
    let historyIndex = -1;
    let messages = {};
    let hudVisible = true; // Track HUD visibility state
    // Track active timers for HUD display
    let activeTimers = {
      window: null,   // Overall window timer (^10)
      events: []      // Individual event timers (^1)
    };
    
    // Safety mechanism for rapid sound triggering
    let soundSafetyMonitor = {
      recentSounds: [],         // Array of timestamps of recent sound events
      maxSoundsWindow: 1000,    // Time window in ms to check for rapid sounds
      maxSoundsThreshold: 10,   // Maximum allowed sounds in window before safety triggers
      safetyEngaged: false,     // Whether safety panic has been triggered
      mobileThreshold: 5,       // Lower threshold for mobile devices
      mobileDetected: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
      lastWarningTime: 0,       // Last time a warning was shown
      cautionShown: false       // Whether initial caution has been shown
    };
    
    // Check if sounds are being triggered too rapidly
    function checkSoundSafety() {
      const now = Date.now();
      
      // Filter out old events outside our window
      soundSafetyMonitor.recentSounds = soundSafetyMonitor.recentSounds.filter(
        time => now - time < soundSafetyMonitor.maxSoundsWindow
      );
      
      // Use lower threshold for mobile devices
      const threshold = soundSafetyMonitor.mobileDetected ? 
                       soundSafetyMonitor.mobileThreshold : 
                       soundSafetyMonitor.maxSoundsThreshold;
      
      // If too many sounds in our window, trigger safety
      if (soundSafetyMonitor.recentSounds.length > threshold && !soundSafetyMonitor.safetyEngaged) {
        console.warn(`Sound safety triggered! ${soundSafetyMonitor.recentSounds.length} sounds in ${soundSafetyMonitor.maxSoundsWindow}ms`);
        
        // Engage safety
        soundSafetyMonitor.safetyEngaged = true;
        
        // Send panic stop to all clients
        socket.emit('panic', { type: 'stop', auto: true });
        
        // Update local interface
        messages[clientId] = `🚨 AUTO-SAFETY: Sound loop detected and stopped`;
        updateHUD();
        
        // Reset safety after a cooling period
        setTimeout(() => {
          soundSafetyMonitor.safetyEngaged = false;
          soundSafetyMonitor.recentSounds = [];
        }, 2000);
      }
    }
    
    // --- Pulse Visuals ---
    let pendingVisualPulses = [];
    let lastPulseTime = 0;
    let pulseActive = false;
    let pulseAlpha = 0;
    // --- End Pulse Visuals ---
    
    // initialize tone.js synth
    // --- Start Audio Overlay Logic ---
    async function startAudioOverlayHandler(e) {
  // Always hide overlay on first tap, regardless of Tone.js status
  if (e) e.stopPropagation();
  
  // Find and hide ALL overlays with this ID (fixes duplicate issue)
  const overlays = document.querySelectorAll('#startAudioOverlay');
  overlays.forEach(overlay => {
    if (overlay) overlay.style.display = 'none';
  });
  
  if (typeof Tone !== 'undefined') {
    try {
      // On iOS/Safari we need user interaction for audio to work
      if (/iPhone|iPad|iPod|Safari/i.test(navigator.userAgent) && !audioStarted) {
        console.log('iOS/Safari detected, ensuring audio context starts...');
      }
      
      // Ensure we await the Tone.start() call to properly initialize audio context
      await Tone.start();
      audioStarted = true;
      console.log('Audio context started:', Tone.context.state);
      
      // Initialize synth immediately to avoid potential issues
      if (!synth) {
        synth = new Tone.Synth().connect(sweepFilter);
        console.log('Synth initialized');
        
        // Play a short test tone to confirm audio is working
        // Use lower volume for test tone to avoid startling users
        const testVol = new Tone.Volume(-20).toDestination();
        const testSynth = new Tone.Synth().connect(testVol);
        testSynth.triggerAttackRelease('C4', 0.1);
        console.log('Test tone played');
        
        // Don't track these initialization sounds in the safety monitor
        if (soundSafetyMonitor) {
          soundSafetyMonitor._testMode = true;
        }
        
        // Also try playing a sine wave to ensure the audio system is fully activated
        setTimeout(() => {
          if (synth) {
            console.log('Playing additional test tone after 500ms...');
            synth.triggerAttackRelease(880, 0.05);
          }
          
          // Turn off test mode after startup
          if (soundSafetyMonitor) {
            setTimeout(() => {
              soundSafetyMonitor._testMode = false;
              console.log('Sound safety monitor test mode disabled');
            }, 500);
          }
        }, 500);
        
        // Show warning on mobile devices about potential audio issues
        if (soundSafetyMonitor && soundSafetyMonitor.mobileDetected) {
          console.log('Mobile device detected - activating sound safety monitoring');
          messages[clientId] = "⚠️ Mobile device detected: Auto-safety will prevent sound loops";
          updateHUD();
          
          // Automatic cautionary panic when first starting on mobile
          // This helps clear any potential loops that might have started
          setTimeout(() => {
            console.log('Sending cautionary panic on mobile device startup');
            socket.emit('panic', { type: 'stop', auto: true, reason: 'mobile_startup' });
          }, 1000);
        }
      }
      
      // Create a visual pulse to show audio is working
      pendingVisualPulses.push(performance.now());
      
      // Update HUD to reflect audio status
      updateHUD();
    } catch (err) {
      console.error('Error starting audio context:', err);
      // Try to show error in HUD
      const hud = document.getElementById('hud');
      if (hud) {
        hud.innerHTML += `<div style="color:red">Audio error: ${err.message}</div>`;
      }
    }
  } else {
    console.error('Tone.js not available!');
  }
}
    window.addEventListener('DOMContentLoaded', () => {
      const overlay = document.getElementById('startAudioOverlay');
      if (overlay) {
        const startAudio = () => {
          if (typeof Tone !== 'undefined' && Tone.context && Tone.context.state !== 'running') {
            Tone.start().then(() => {
              audioStarted = true;
              console.log('[overlay] Audio resumed via Tone.start()');
            });
          } else {
            audioStarted = true;
          }
        };
        overlay.addEventListener('click', (e) => { startAudio(); startAudioOverlayHandler(e); });
        overlay.addEventListener('touchstart', (e) => { startAudio(); startAudioOverlayHandler(e); });
      }
    });
    // --- End Start Audio Overlay Logic ---
    
    // p5.js setup
    function setup() {
      createCanvas(windowWidth, windowHeight);
      windowResized();
      // Crear analyser para el master output
      if (typeof Tone !== 'undefined' && Tone.Destination && !meterAnalyser) {
        meterAnalyser = Tone.context.createAnalyser();
        meterAnalyser.fftSize = 256;
        meterDataArray = new Uint8Array(meterAnalyser.fftSize);
        // Conectar analyser al master (API Tone.js >=14)
        if (typeof Tone.Destination.connect === 'function') {
          Tone.Destination.connect(meterAnalyser);
        } else if (Tone.Destination.node && typeof Tone.Destination.node.connect === 'function') {
          Tone.Destination.node.connect(meterAnalyser);
        }
      }
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
    
    function draw() {
  // --- Pulse Visuals ---
  const now = performance.now();
  // Remove and trigger any pulses due now
  while (pendingVisualPulses.length && pendingVisualPulses[0] <= now) {
    lastPulseTime = now;
    pulseActive = true;
    pulseAlpha = 255; // full brightness
    pendingVisualPulses.shift();
  }
  // Draw the pulse visual if active
  if (pulseActive) {
    fill(255, pulseAlpha);
    noStroke();
    ellipse(width / 2, height / 2, 200, 200); // expanding circle
    pulseAlpha -= 10; // fade out
    if (pulseAlpha <= 0) {
      pulseActive = false;
    }
  }
  // --- End Pulse Visuals ---
  background(0);
  for (let id in clients) {
    let c = clients[id];
    
    // Asegurarse de que las propiedades de posición actual existen
    if (c && c.position && typeof c.position.xNorm === 'number' && typeof c.position.yNorm === 'number') {
      // Si no hay posición interpolada, inicializarla
      if (!c.interpolatedPos) {
        c.interpolatedPos = {
          x: c.position.xNorm * windowWidth,
          y: c.position.yNorm * windowHeight
        };
        c.fromPos = { ...c.interpolatedPos };
        c.toPos = { ...c.interpolatedPos };
        c.moveStartTime = millis ? millis() : Date.now();
      }
      
      // Calcular posición objetivo
      let targetX = c.position.xNorm * windowWidth;
      let targetY = c.position.yNorm * windowHeight;
      
      // Timer-based interpolation with 300ms transitions (smooth but responsive)
      const duration = 300; // ms - quick transitions for better responsiveness
      let now = millis ? millis() : Date.now();
      if ((Math.abs(c.toPos.x - targetX) > 1) || (Math.abs(c.toPos.y - targetY) > 1)) {
        // New target detected, start new transition
        c.fromPos = { x: c.interpolatedPos.x, y: c.interpolatedPos.y };
        c.toPos = { x: targetX, y: targetY };
        c.moveStartTime = now;
      }
      // Apply easeOutCubic easing for smoother motion
      let t = constrain((now - c.moveStartTime) / duration, 0, 1);
      let easing = 1 - Math.pow(1 - t, 3); // easeOutCubic for smoother transitions
      c.interpolatedPos.x = lerp(c.fromPos.x, c.toPos.x, easing);
      c.interpolatedPos.y = lerp(c.fromPos.y, c.toPos.y, easing);
      
      // --- VU meter color for border ---
      let vuAlpha = map(meterLevel, 0, 1, 80, 255);
      let vuR = meterLevel > 0.5 ? 255 : Math.floor(255 * (meterLevel * 2));
      let vuG = meterLevel > 0.5 ? Math.floor(255 * (2 - meterLevel * 2)) : 255;
      let vuColor = color(vuR, vuG, 0, vuAlpha);
      
      // --- Wireframe/Idle: transparent fill, ID color border ---
      if (c.physics && typeof c.physics.update === 'function') {
        // Generator active: border = VU meter, fill transparent
        noFill();
        c.physics.update();
        let pts = c.physics.getShapePoints(c.interpolatedPos.x, c.interpolatedPos.y);
        stroke(vuColor);
        strokeWeight(4 + meterLevel * 8);
        drawingContext.shadowBlur = 24 * meterLevel;
        drawingContext.shadowColor = `rgba(${vuR},${vuG},0,${meterLevel})`;
        beginShape();
        for (let pt of pts) vertex(pt.x, pt.y);
        endShape(CLOSE);
        drawingContext.shadowBlur = 0;
      } else {
        // Idle: border = ID color, fill transparent
        noFill();
        stroke((c && c.color) ? c.color : '#3498DB');
        strokeWeight(4);
        drawingContext.shadowBlur = 0;
        
        // Handle role-based circle size with transitions
        const conductorSize = 100;
        const performerSize = 60;
        const targetSize = c.role === 'conductor' ? conductorSize : performerSize;
        
        // Initialize size tracking if not exists
        if (c.currentSize === undefined) {
          c.currentSize = targetSize;
          c.fromSize = targetSize;
          c.toSize = targetSize;
          c.sizeChangeTime = now;
        }
        
        // Check if role changed (target size changed)
        if (Math.abs(c.toSize - targetSize) > 1) {
          // Start size transition
          c.fromSize = c.currentSize;
          c.toSize = targetSize;
          c.sizeChangeTime = now;
          console.log(`Role transition for ${id}: ${c.role} (${c.fromSize} → ${c.toSize})`);
        }
        
        // Animate size over 500ms with easeOutCubic
        const sizeDuration = 500; // ms
        let sizeT = constrain((now - c.sizeChangeTime) / sizeDuration, 0, 1);
        let sizeEasing = 1 - Math.pow(1 - sizeT, 3); // easeOutCubic
        c.currentSize = lerp(c.fromSize, c.toSize, sizeEasing);
        
        // Draw the circle with current interpolated size
        ellipse(
          c.interpolatedPos.x,
          c.interpolatedPos.y,
          c.currentSize,
          c.currentSize
        );
      }
      
      // Dibujar línea entre posición actual y objetivo si están lejos
      let distance = dist(c.interpolatedPos.x, c.interpolatedPos.y, targetX, targetY);
      if (distance > 5) {
        stroke(c.color || '#3498DB');
        strokeWeight(1);
        line(c.interpolatedPos.x, c.interpolatedPos.y, targetX, targetY);
        noStroke();
      }
    }
  }
  
  // Draw VU meter horizontal bar at bottom
  drawVUMeter();
}

// Draws a horizontal VU meter at the bottom of the screen
function drawVUMeter() {
  if (meterAnalyser && meterDataArray) {
    // Get current audio levels
    meterAnalyser.getByteFrequencyData(meterDataArray);
    
    // Calculate average level
    let sum = 0;
    for (let i = 0; i < meterDataArray.length; i++) {
      sum += meterDataArray[i];
    }
    const average = sum / meterDataArray.length;
    
    // Convert to dB scale (approximation)
    const dB = 20 * Math.log10(average / 255 + 1e-10);
    const level = Math.max(0, Math.min(1, (dB + 60) / 60)); // Normalize between 0 and 1
    
    // Draw meter background
    noStroke();
    fill(0, 0, 0, 180);
    rect(0, height - 4, width, 4); // Increased height to 4px for better visibility
    
    // Draw meter level with color based on level
    const meterWidth = width * level;
    // Color gradient from green to yellow to red based on level
    let r = level > 0.5 ? 255 : Math.floor(255 * (level * 2));
    let g = level > 0.5 ? Math.floor(255 * (2 - level * 2)) : 255;
    fill(r, g, 0);
    rect(0, height - 4, meterWidth, 4);
    
    // Add digital readout for debugging
    if (level > 0.01) {
      fill(255);
      textSize(10);
      textAlign(LEFT);
      text(`${dB.toFixed(1)} dB`, 5, height - 8);
    }
    
    // Update global meter level for other components to use
    meterLevel = level;
    
    // Log audio level to console periodically (roughly once per second)
    if (frameCount % 60 === 0 && level > 0.01) {
      console.log(`[Audio Level] ${dB.toFixed(1)} dB, normalized: ${level.toFixed(3)}`);
    }
  }
}
    
    // manual position update
    let lastPositionUpdate = 0;
    function updatePosition(x, y) {
      // Verificar que las coordenadas son válidas
      if (isNaN(x) || isNaN(y) || x === undefined || y === undefined) {
        console.error('[updatePosition] Coordenadas inválidas:', x, y);
        return;
      }
      
      let xNorm = constrain(x / windowWidth, 0, 1);
      let yNorm = constrain(y / windowHeight, 0, 1);
      console.log('[updatePosition] input:', x, y, 'normalized:', xNorm, yNorm, 'window:', windowWidth, windowHeight);
      
      // Límite de frecuencia de actualización para evitar saturar la red
      if (Date.now() - lastPositionUpdate > 50) { // Actualización cada 50ms máximo
        lastPositionUpdate = Date.now();
        
        // Verificar que el cliente existe
        if (!clients[clientId]) {
          console.warn('[updatePosition] Cliente no existe:', clientId);
          return;
        }
        
        // Actualizar posición localmente
        clients[clientId].position = { xNorm, yNorm };
        
        // Siempre enviar la posición al servidor, sin importar audioStarted
        let locationMsg = `${clientName}/room/${xNorm.toFixed(2)}/${yNorm.toFixed(2)}`;
        socket.emit('location', locationMsg);
        messages[clientId] = locationMsg;
        console.log(`position updated: x=${x}, y=${y}, xNorm=${xNorm.toFixed(2)}, yNorm=${yNorm.toFixed(2)}`);
        
        // Crear un pulso visual para indicar la actualización de posición
        pendingVisualPulses.push(performance.now());
        
        updateHUD();
      }
    }
    
    // Test audio system functionality
    function testAudioSystem() {
      if (!audioStarted) {
        console.warn('Audio not started yet. Attempting to start...');
        Tone.start().then(() => {
          audioStarted = true;
          runAudioTest();
        }).catch(err => {
          console.error('Failed to start audio in test:', err);
          messages[clientId] = 'Error: ' + err.message;
          updateHUD();
        });
      } else {
        runAudioTest();
      }
    }
    
    function runAudioTest() {
      console.log('Running audio test sequence...');
      messages[clientId] = 'Testing audio...';
      updateHUD();
      
      // Make sure synth is initialized
      if (!synth) synth = new Tone.Synth().connect(sweepFilter);
      
      // Track messages for display
      const messages = {};
      
      // Track active timers for display in HUD
      const activeTimers = {
        window: null,  // Overall window timer (^10)
        events: []     // Individual event timers (^1)
      };
      
      // Update timers every 100ms
      setInterval(updateTimers, 100);
      
      // Play a scale of notes
      const testNotes = ['C4', 'E4', 'G4', 'C5'];
      const interval = 0.2;
      
      testNotes.forEach((note, i) => {
        setTimeout(() => {
          synth.triggerAttackRelease(note, 0.1);
          console.log(`Test note ${i+1}/${testNotes.length}: ${note}`);
          // Visual feedback
          pendingVisualPulses.push(performance.now());
          if (i === testNotes.length - 1) {
            messages[clientId] = 'Audio test complete';
            updateHUD();
            setTimeout(() => {
              if (messages[clientId] === 'Audio test complete') {
                messages[clientId] = '';
                updateHUD();
              }
            }, 2000);
          }
        }, i * interval * 1000);
      });
    }
    
    // Display detailed audio status
    function displayAudioStatus() {
      if (!Tone) {
        messages[clientId] = 'Tone.js not available';
        updateHUD();
        return;
      }
      
      const statusInfo = {
        'Context State': Tone.context.state,
        'Audio Started': audioStarted ? 'Yes' : 'No',
        'Synth Initialized': synth ? 'Yes' : 'No',
        'Sample Rate': Tone.context.sampleRate,
        'Audio Output': meterLevel > 0.01 ? 'Active' : 'Silent',
        'Output Level': (meterLevel * 100).toFixed(1) + '%'
      };
      
      console.table(statusInfo);
      
      let statusMsg = 'Audio Status:\n';
      for (const [key, value] of Object.entries(statusInfo)) {
        statusMsg += `${key}: ${value}\n`;
      }
      
      messages[clientId] = statusMsg;
      updateHUD();
    }
    
    // Track double click/touch
    let lastClickTime = 0;
    let lastTapTime = 0;
    const doubleClickThreshold = 300; // ms between clicks to count as double-click
    
    // Fullscreen toggle functions
    function toggleFullScreen() {
      if (!document.fullscreenElement && 
          !document.mozFullScreenElement && 
          !document.webkitFullscreenElement && 
          !document.msFullscreenElement) {
        // Enter fullscreen
        const docEl = document.documentElement;
        if (docEl.requestFullscreen) {
          docEl.requestFullscreen();
        } else if (docEl.msRequestFullscreen) {
          docEl.msRequestFullscreen();
        } else if (docEl.mozRequestFullScreen) {
          docEl.mozRequestFullScreen();
        } else if (docEl.webkitRequestFullscreen) {
          docEl.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        }
        console.log('Entering fullscreen mode');
        messages[clientId] = '⤢ Fullscreen Mode';
      } else {
        // Exit fullscreen
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        }
        console.log('Exiting fullscreen mode');
        messages[clientId] = '⤮ Normal Mode';
      }
      updateHUD();
    }
    
    function mousePressed() {
      const currentTime = Date.now();
      
      // Check for double-click
      if (currentTime - lastClickTime < doubleClickThreshold) {
        // This is a double-click
        toggleFullScreen();
      } else {
        // This is a single click, handle regular position update
        updatePosition(mouseX, mouseY);
      }
      
      // Update the time of the last click
      lastClickTime = currentTime;
    }
    
    function touchStarted() {
      console.log('touchStarted event fired');
      const currentTime = Date.now();
      
      // Check for double-tap
      if (currentTime - lastTapTime < doubleClickThreshold) {
        // This is a double-tap
        toggleFullScreen();
      } else if (touches.length > 0) {
        // This is a single tap, handle regular position update
        updatePosition(touches[0].x, touches[0].y);
      }
      
      // Update the time of the last tap
      lastTapTime = currentTime;
      
      return false; // Prevent default behavior in iOS
    }
    
    function touchMoved() {
      console.log('touchMoved event fired');
      if (touches.length > 0) {
        updatePosition(touches[0].x, touches[0].y);
      }
      return false; // Prevenir comportamiento por defecto en iOS
    }
    
    // sensor handling (for synth only)
    let lastSensorUpdate = 0;
    // Mejorar manejo de eventos de orientación para iOS
    function setupDeviceMotion() {
      console.log('Configurando sensores de movimiento...');
      
      // Manejar diferentes implementaciones de permisos (iOS 13+)
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        console.log('Dispositivo requiere permiso explícito para sensores');
        // iOS 13+ requiere permiso explícito
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') {
              console.log('Permiso de sensores concedido');
              window.addEventListener('deviceorientation', handleDeviceOrientation);
            } else {
              console.log('Permiso de sensores denegado');
              messages[clientId] = 'Se requiere permiso para sensores';
              updateHUD();
            }
          })
          .catch(console.error);
      } else {
        // Dispositivos que no requieren permiso explícito
        window.addEventListener('deviceorientation', handleDeviceOrientation);
      }
    }
    
    // Manejar eventos de orientación
    function handleDeviceOrientation(event) {
      if (!audioStarted) return;
      if (Date.now() - lastSensorUpdate < 100) return;
      lastSensorUpdate = Date.now();
      
      // Verificar que los datos son válidos
      if (event.beta === null || event.gamma === null) {
        console.log('Datos de orientación no disponibles');
        return;
      }
      
      let data = { beta: event.beta, gamma: event.gamma };
      console.log(`Sensor: beta=${data.beta?.toFixed(2)}, gamma=${data.gamma?.toFixed(2)}`);
      
      if (clients[clientId]) {
        socket.emit('sensorData', data);
      }
      
      if (role === 'performer' && synth) {
        let freq = map(data.gamma, -90, 90, 200, 1000);
        synth.set({ oscillator: { frequency: freq } });
        synth.triggerAttackRelease(freq, '8n');
      }
    }
    
    // Iniciar configuración de sensores al cargar
    window.addEventListener('DOMContentLoaded', () => {
      setupDeviceMotion();
      
      // Set up timer update interval (10 updates per second)
      setInterval(updateTimers, 100);
    });
    
    // socket.io events
    socket.on('init', (data) => {
      clientId = data.id;
      clientName = data.name || 'performer';
      role = data.role;
      clients = data.clients;
      
      console.log(`init: name=${clientName}, role=${role}, clients=${JSON.stringify(Object.keys(clients))}`);
      
      // Send acknowledgment back to server
      socket.emit('client_ready', { id: clientId, audioReady: audioStarted });
      console.log('Sent client_ready acknowledgment to server');
      
      updateHUD();
    });
    
    socket.on('clientUpdate', (updatedClients) => {
      clients = updatedClients;
      // Always update role from latest server state for this client
      if (clients[clientId] && clients[clientId].role) {
        role = clients[clientId].role;
      }
      console.log('[clientUpdate] clients:', clients, 'role:', role);
      updateHUD();
    });

    // Listen for generator events (sine commands sent to all clients)
    socket.on('generator', (data) => {
      console.log(`[generator] Received event:`, data);
      
      // Send acknowledgment of receipt back to server
      socket.emit('generator_received', { id: clientId, dataType: data.type });
      
      if (data.type === 'sine' || data.type === 's') {
        if (!audioStarted) {
          console.warn('Audio not started. Starting audio context...');
          // Try to start audio context on this event
          Tone.start().then(() => {
            audioStarted = true;
            playGeneratorSound(data);
            // Confirm successful playback
            socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
          }).catch(err => {
            console.error('Failed to auto-start audio:', err);
            // Report failure
            socket.emit('generator_played', { id: clientId, success: false, error: err.message });
          });
        } else {
          playGeneratorSound(data);
          // Confirm successful playback
          socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
        }
      } else if (data.type === 'sf') {
        console.log('SF Generator event received - attempting to process');
        
        // Check if runSfGenerator is available
        if (typeof window.runSfGenerator === 'function') {
          console.log('Using window.runSfGenerator');
          window.runSfGenerator({ ...data, onTrigger: playGeneratorSound });
          socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
        } else if (typeof runSfGenerator === 'function') {
          console.log('Using local runSfGenerator');
          runSfGenerator({ ...data, onTrigger: playGeneratorSound });
          socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
        } else {
          console.error('runSfGenerator function not found! Creating direct sounds instead.');
          
          // Fallback implementation if runSfGenerator isn't available
          const count = data.count || 5;
          const minFreq = data.minFreq || 300;
          const maxFreq = data.maxFreq || 500;
          const dur = data.dur || 1;
          const window = data.window || 10;
          
          for (let i = 0; i < count; i++) {
            setTimeout(() => {
              const freq = minFreq + Math.random() * (maxFreq - minFreq);
              playGeneratorSound({ type: 'sf', freq, dur, vol: data.vol || 9 });
            }, Math.random() * window * 1000);
          }
          
          socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
        }
      }
    });
    
    // Handle panic events from other clients
    socket.on('panic', (data) => {
      console.log(`Received panic ${data.type} from ${data.from}`, data);
      
      if (data.type === 'stop') {
        // Immediate stop
        if (typeof Tone !== 'undefined') {
          Tone.Transport.cancel();
          Tone.Transport.stop();
          if (typeof Tone.getDestination === 'function') {
            Tone.getDestination().mute = true;
            setTimeout(() => Tone.getDestination().mute = false, 50);
          }
          // Force dispose any lingering synths
          if (sweepFilter) sweepFilter.dispose();
          sweepFilter = new Tone.Filter({
            frequency: 2000,
            type: "lowpass",
            rolloff: -12
          }).toDestination();
        }
        
        // Clear all timers
        activeTimers.window = null;
        activeTimers.events = [];
        
        // Clear sound safety tracking
        if (soundSafetyMonitor) {
          soundSafetyMonitor.recentSounds = [];
        }
        
        // Different message based on type of panic
        let message;
        if (data.auto) {
          if (data.reason === 'mobile_startup') {
            message = `🔔 Startup safety check - Mobile device ready`;
          } else {
            message = `🚨 AUTO-SAFETY: Sound loop detected and stopped`;
          }
        } else {
          const sender = clients[data.from]?.name || 'another user';
          message = `🛑 PANIC STOP from ${sender}`;
        }
        
        messages[clientId] = message;
        updateHUD();
        
      } else if (data.type === 'fade') {
        // Fade out over specified duration
        if (typeof Tone !== 'undefined' && typeof Tone.getDestination === 'function') {
          const dest = Tone.getDestination();
          const originalVolume = dest.volume.value;
          const fadeTime = data.duration || 6000; // Default to 6 seconds
          const fadeSteps = Math.floor(fadeTime / 100); // 10 steps per second
          const interval = fadeTime / fadeSteps;
          let step = 0;
          
          // Update message
          const sender = clients[data.from]?.name || 'another user';
          messages[clientId] = `🔇 PANIC FADE from ${sender}`;
          updateHUD();
          
          // Fade out gradually
          const fadeInterval = setInterval(() => {
            step++;
            if (step >= fadeSteps) {
              clearInterval(fadeInterval);
              dest.volume.value = originalVolume; // Reset for future sounds
              Tone.Transport.cancel();
              Tone.Transport.stop();
              // Force dispose any lingering synths
              if (sweepFilter) sweepFilter.dispose();
              sweepFilter = new Tone.Filter({
                frequency: 2000,
                type: "lowpass",
                rolloff: -12
              }).toDestination();
              
              // Clear all timers at the end of fade out
              activeTimers.window = null;
              activeTimers.events = [];
              
              // Update message
              messages[clientId] = `🔇 FADE COMPLETED - From ${sender}`;
              updateHUD();
            } else {
              // Exponential fadeout curve
              const fraction = 1 - (step / fadeSteps);
              const newVolume = originalVolume - (60 * (1 - Math.pow(fraction, 3)));
              dest.volume.value = newVolume;
            }
          }, interval);
        }
      }
    });
    
    // Create a shared ConvolutionReverb effect that can be reused
    let reverbEffect = null;
    
    // Helper function to play generator sounds
    function playGeneratorSound(data) {
      console.log("playGeneratorSound called with:", JSON.stringify(data, null, 2));
      
      // --- Sound Safety: Track this sound event and check for rapid triggering ---
      // Don't track sounds during initialization/testing
      if (soundSafetyMonitor && !data._isInternalTest && !soundSafetyMonitor._testMode) {
        // Record this sound event
        soundSafetyMonitor.recentSounds.push(Date.now());
        
        // Check if we're seeing too many sounds in a short period
        checkSoundSafety();
        
        // Show caution message on mobile if not shown yet
        if (soundSafetyMonitor.mobileDetected && !soundSafetyMonitor.cautionShown) {
          messages[clientId] = "ℹ️ Mobile device detected. Auto-safety will trigger if sounds loop too rapidly.";
          updateHUD();
          soundSafetyMonitor.cautionShown = true;
        }
      }
      
      // --- Physics: if sine event, assign SineCirclePhysics to this client ---
      if ((data.type === 'sine' || data.type === 'sf') && clients[clientId]) {
        if (!clients[clientId].physics || typeof clients[clientId].physics.trigger !== 'function') {
          clients[clientId].physics = new SineCirclePhysics(clients[clientId].role === 'conductor' ? 50 : 30);
        }
        clients[clientId].physics.trigger(performance.now());
      }

  // Add visual feedback for audio events
  pendingVisualPulses.push(performance.now() + 100); // Add pulse with slight delay

  try {
    let isPoly = data.type === 'sf' || typeof data.vol === 'number';
    console.log(`🎹 Sound type check - isPoly: ${isPoly}, data.type: '${data.type}', has vol: ${typeof data.vol === 'number'}`);
    
    if (isPoly) {
      try {
        // For SF type sounds, use an envelope with fade-in and fade-out
        if (data.type === 'sf') {
          console.log(`🔈 Creating new synth for SF sound with envelope`);
          
          // Calculate fade times based on duration (15% fade-in, 25% fade-out)
          const fadeInTime = Math.min(0.15 * data.dur, 0.3); // max 300ms
          const fadeOutTime = Math.min(0.25 * data.dur, 0.5); // max 500ms
          const sustainTime = data.dur - fadeInTime - fadeOutTime;
          
          // Create effects chain - reverb and/or panner as needed
          let finalOutput = sweepFilter;
          let reverbNode = null;
          let pannerNode = null;
          
          // Create reverb if specified
          if (data.reverb) {
            // Calculate reverb time based on parameter (1-9 scale) - exponential increase
            // r1 = 0.05s, r5 = 2s, r9 = 8s (much more dramatic range)
            const reverbTime = data.reverb === 1 ? 0.05 : Math.pow(data.reverb / 2, 2);
            
            // Wet/dry mix increases with higher reverb values
            const wetLevel = Math.min(0.8, 0.3 + (data.reverb / 9) * 0.5);
            
            try {
              // Create a reverb effect
              reverbNode = new Tone.Reverb({
                decay: reverbTime,
                wet: wetLevel,
                preDelay: data.reverb > 5 ? 0.03 : 0.01
              }).connect(sweepFilter);
              
              // Make reverb available immediately without waiting for buffer generation
              reverbNode.generate();
              finalOutput = reverbNode;
              console.log(`🔊 Reverb created with decay: ${reverbTime}s (level ${data.reverb}/9)`);
            } catch (err) {
              console.error('Failed to create reverb:', err);
            }
          }
          
          // Create panner if needed
          if (typeof data.pan === 'number') {
            pannerNode = new Tone.Panner(data.pan);
            
            // Connect panner to the right destination
            if (reverbNode) {
              pannerNode.connect(reverbNode);
            } else {
              pannerNode.connect(sweepFilter);
            }
            
            finalOutput = pannerNode;
            console.log(`🔊 SF Panner created with position: ${data.pan}`);
          }
          
          // Create a synth with envelope
          let thisSynth = new Tone.Synth({
            envelope: {
              attack: fadeInTime,
              decay: 0.01,
              sustain: 1,
              release: fadeOutTime
            }
          });
          
          // Connect to the effect chain
          if (pannerNode) {
            thisSynth.connect(pannerNode);
          } else if (reverbNode) {
            thisSynth.connect(reverbNode);
          } else {
            thisSynth.connect(sweepFilter);
          }
          
          // Set volume
          if (typeof data.vol === 'number' && thisSynth.volume) {
            let dbValue = Tone.gainToDb(data.vol / 9);
            thisSynth.volume.value = dbValue;
            console.log(`🔊 SF Volume: ${data.vol}/9 => ${dbValue}dB, envelope: attack=${fadeInTime}s, release=${fadeOutTime}s`);
          }
          
          // Add reverb info to the log
          const reverbInfo = data.reverb ? `, reverb: ${data.reverb}/9` : '';
          console.log(`🎵 PLAYING SF: ${data.freq}Hz for ${data.dur}s (envelope: ${fadeInTime}s→${sustainTime}s→${fadeOutTime}s)${reverbInfo}`);
          thisSynth.triggerAttackRelease(data.freq, sustainTime + fadeInTime);
          
          // Add extra time for reverb tail before disposing - match our new exponential scale
          const extraTime = data.reverb ? (data.reverb > 1 ? Math.pow(data.reverb / 2, 2) * 1000 : 100) : 0;
          setTimeout(() => {
            console.log(`🗑️ Disposing SF synth and effects after ${data.dur}s`);
            thisSynth.dispose();
            // Also dispose of the effects
            if (reverbNode) reverbNode.dispose();
            if (pannerNode) pannerNode.dispose();
          }, data.dur * 1000 + 200 + extraTime);
        } else {
          // Regular polyphonic sound (not SF type)
          console.log(`🔈 Creating new synth for polyphonic sound`);
          
          // Create effects chain for regular sounds too
          let finalOutput = sweepFilter;
          let reverbNode = null;
          let pannerNode = null;
          
          // Create reverb if specified
          if (data.reverb) {
            // Calculate reverb time based on parameter (1-9 scale) - exponential increase
            // r1 = 0.05s, r5 = 2s, r9 = 8s (much more dramatic range)
            const reverbTime = data.reverb === 1 ? 0.05 : Math.pow(data.reverb / 2, 2);
            
            // Wet/dry mix increases with higher reverb values
            const wetLevel = Math.min(0.8, 0.3 + (data.reverb / 9) * 0.5);
            
            try {
              // Create a reverb effect
              reverbNode = new Tone.Reverb({
                decay: reverbTime,
                wet: wetLevel,
                preDelay: data.reverb > 5 ? 0.03 : 0.01
              }).connect(sweepFilter);
              
              // Make reverb available immediately without waiting for buffer generation
              reverbNode.generate();
              finalOutput = reverbNode;
              console.log(`🔊 Reverb created with decay: ${reverbTime}s (level ${data.reverb}/9)`);
            } catch (err) {
              console.error('Failed to create reverb:', err);
            }
          }
          
          // Create panner if needed
          if (typeof data.pan === 'number') {
            pannerNode = new Tone.Panner(data.pan);
            
            // Connect panner to the right destination
            if (reverbNode) {
              pannerNode.connect(reverbNode);
            } else {
              pannerNode.connect(sweepFilter);
            }
            
            finalOutput = pannerNode;
            console.log(`🔊 Panner created with position: ${data.pan}`);
          }
          
          // Create the synth
          let thisSynth = new Tone.Synth();
          
          // Connect to the effect chain
          if (pannerNode) {
            thisSynth.connect(pannerNode);
          } else if (reverbNode) {
            thisSynth.connect(reverbNode);
          } else {
            thisSynth.connect(sweepFilter);
          }
          
          if (typeof data.vol === 'number' && thisSynth.volume) {
            let dbValue = Tone.gainToDb(data.vol / 9);
            thisSynth.volume.value = dbValue;
            console.log(`🔊 Volume set to: ${data.vol}/9 => ${dbValue}dB`);
          }
          
          // Add reverb info to the log
          const reverbInfo = data.reverb ? `, reverb: ${data.reverb}/9` : '';
          console.log(`🎵 PLAYING: ${data.freq}Hz for ${data.dur}s, vol: ${data.vol ?? 'default'}${reverbInfo}`);
          thisSynth.triggerAttackRelease(data.freq, data.dur);
          
          // Add extra time for reverb tail before disposing - match our new exponential scale
          const extraTime = data.reverb ? (data.reverb > 1 ? Math.pow(data.reverb / 2, 2) * 1000 : 100) : 0;
          setTimeout(() => {
            console.log(`🗑️ Disposing synth after ${data.dur}s`);
            thisSynth.dispose();
            // Also dispose of the effects
            if (reverbNode) reverbNode.dispose();
            if (pannerNode) pannerNode.dispose();
          }, data.dur * 1000 + 100 + extraTime);
        }
        messages[clientId] = `sf${data.freq}^${data.dur}`;
        console.log(`[sf] generator event played: ${data.freq}Hz for ${data.dur}s, vol: ${data.vol ?? 'default'}`);
      } catch (err) {
        console.error('Error playing polyphonic sound:', err);
      }
    } else {
      // Monophonic fallback for 's'
      if (!synth) {
        try {
          synth = new Tone.Synth().connect(sweepFilter);
        } catch (err) {
          console.error('Failed to initialize synth:', err);
          return;
        }
      }
      if (typeof data.vol === 'number' && synth.volume) {
        synth.volume.value = Tone.gainToDb(data.vol / 9);
      }
      console.log(`(sine/mono) Reproduciendo: ${data.freq}Hz por ${data.dur}s, vol: ${data.vol ?? 'default'}`);
      synth.triggerAttackRelease(data.freq, data.dur);
      messages[clientId] = `s${data.freq}^${data.dur}`;
      console.log(`[sine] generator event played: ${data.freq}Hz for ${data.dur}s, vol: ${data.vol ?? 'default'}`);
    }

    // Añadir un pulso visual para mostrar que se está reproduciendo el sonido
    document.body.style.boxShadow = 'inset 0 0 20px rgba(0,255,0,0.5)';
    setTimeout(() => {
      document.body.style.boxShadow = 'none';
    }, 100);
  } catch (err) {
        console.error('Error playing sound:', err);
        messages[clientId] = `Error: ${err.message}`;
      }
      updateHUD();
    }
    
    socket.on('control', (data) => {
      if (role === 'performer' && audioStarted) {
        if (data.type === 'freq') {
          if (!synth) synth = new Tone.Synth().connect(sweepFilter);
          synth.set({ oscillator: { frequency: data.value } });
          synth.triggerAttackRelease(data.value, '8n');
          messages[clientId] = `freq ${data.value}`;
        } else if (data.type === 'sine') {
          if (!synth) synth = new Tone.Synth().connect(sweepFilter);
          synth.triggerAttackRelease(data.freq, data.dur);
          messages[clientId] = `s${data.freq}^${data.dur}`;
          console.log(`[sine] Remote: ${data.freq}Hz for ${data.dur}s`);
        }
      }
    });
    
    function sendControl(data) {
      if (role === 'conductor' && audioStarted) {
        socket.emit('conductorControl', data);
      } else if (role === 'performer' && audioStarted) {
        if (data.type === 'sf') {
         // Play sf events for this client
         if (typeof runSfGenerator === 'function') {
           runSfGenerator({ ...data, onTrigger: playGeneratorSound });
         }
         socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
       } else if (data.type === 'sine') {
          if (!synth) synth = new Tone.Synth().connect(sweepFilter);
          synth.triggerAttackRelease(data.freq, data.dur);
          console.log(`[sine] Local: ${data.freq}Hz for ${data.dur}s`);
        }
      }
    }
    
    function updateHUD() {
  // Always update role from latest server state for this client
  if (clients[clientId] && clients[clientId].role) {
    role = clients[clientId].role;
  }
  // Debug: log all clients
  console.log('[updateHUD] clients:', clients);

  // main HUD (lower-left)
  let hud = `name: ${clientName.toLowerCase()}\n`; 
  hud += `role: ${role ? role.toLowerCase() : 'performer'}\n`; 
      const audioStatus = audioStarted ? 
        (typeof Tone !== 'undefined' && Tone.context ? `on (${Tone.context.state})` : 'on') : 
        'tap "start audio" to begin';
      hud += `audio: ${audioStatus}\n`;
      
      // Display active timers (if any)
      if (activeTimers.window) {
        hud += `${activeTimers.window.remaining}\n`;
      }
      
      // Show individual event timers (max 3)
      if (activeTimers.events.length > 0) {
        const displayEvents = activeTimers.events.slice(0, 3); // Show max 3 timers
        const eventTimes = displayEvents.map(t => t.remaining).join(' ');
        hud += `${eventTimes}\n`;
      }
      if (role === 'conductor') {
        hud += `commands: s220 (sine), test, audiostatus\n`;
      }
      if (clients[clientId] && clients[clientId].sensorData) {
        hud += `beta: ${clients[clientId].sensorData.beta?.toFixed(2) || 'n/a'}\n`;
        hud += `gamma: ${clients[clientId].sensorData.gamma?.toFixed(2) || 'n/a'}\n`;
      }
      if (clients[clientId] && clients[clientId].position) {
        hud += `position: ${clientName}/room/${clients[clientId].position.xNorm?.toFixed(2) || '0.50'}/${clients[clientId].position.yNorm?.toFixed(2) || '0.50'}\n`;
      }
      document.getElementById('hud').innerHTML = hud;
      
      // performers HUD (upper-right)
      let performersHud = `<span class="version-link" onclick="toggleReadmeModal(); console.log('Version link clicked');">trawun v${TRAWUN_VERSION}</span>
`;
      performersHud += `performers: ${Object.keys(clients).length}
`;
      for (let id in clients) {
        let c = clients[id];
        if (!id || !c || !c.name || !c.color || !c.position || typeof c.position.xNorm !== 'number' || typeof c.position.yNorm !== 'number') {
          continue;
        }
        let isConductor = c.role === 'conductor';
        let name = c.name;
        let color = c.color;
        let coords = `x: ${c.position.xNorm.toFixed(2)}, y: ${c.position.yNorm.toFixed(2)}`;
        let msg = messages[id] ? `<span style="color:#fff;opacity:0.8;font-size:13px;">${messages[id]}</span>` : '';
     performersHud += `${isConductor ? '<span style="color:#ff2222;font-weight:bold;margin-right:6px;">C</span> ' : ''}`;
performersHud += `<span style="color: ${color};">${name.toLowerCase()}`;

// Minimalistic sensor feedback (1-9, no labels)
if (c.sensorData) {
  // Map beta [-90,90] to 1-9
  let beta = c.sensorData.beta;
  let betaDigit = (typeof beta === "number")
    ? Math.max(1, Math.min(9, Math.round(((beta + 90) / 180) * 8 + 1)))
    : "";
  // Map gamma [-90,90] to 1-9
  let gamma = c.sensorData.gamma;
  let gammaDigit = (typeof gamma === "number")
    ? Math.max(1, Math.min(9, Math.round(((gamma + 90) / 180) * 8 + 1)))
    : "";
  // Show both, no labels
  performersHud += `<span style="margin-left:4px;font-size:13px;opacity:0.7;">${betaDigit}${gammaDigit}</span>`;
}

performersHud += `</span> <span class="client-data" style="color: ${color}; opacity: 0.3;">${coords}</span> ${msg}\n`;
      }
      document.getElementById('performers-hud').innerHTML = performersHud;
      
      // command prompt for conductor
      let promptDiv = document.getElementById('commandPrompt');
      if (!promptDiv) {
        let input = document.createElement('input');
        input.id = 'commandPrompt';
        input.type = 'text';
        input.placeholder = 'press i for command input / space for next sound (s200 u10^2)'; 
        input.classList.add('ready');
        document.getElementById('hud').appendChild(input);
        
        // Enhanced keyboard shortcuts
        document.addEventListener('keydown', function(e) {
          // IMPORTANT: Always allow command entry regardless of audio state
          // Only focus prompt if not already in an input/textarea and not with modifiers
          if ((e.key === 'i' || e.key === ' ') && 
              !e.ctrlKey && !e.metaKey && !e.altKey && 
              document.activeElement.tagName !== 'INPUT' && 
              document.activeElement.tagName !== 'TEXTAREA') {
            
            let prompt = document.getElementById('commandPrompt');
            if (prompt) {
              // Add visual feedback
              prompt.classList.add('ready');
              
              // Focus the prompt and prevent focus loss
              prompt.focus();
              
              // Prevent any focus stealing for a short time
              setTimeout(() => {
                // Re-focus if focus was lost
                if (document.activeElement !== prompt) {
                  console.log('Re-focusing command prompt');
                  prompt.focus();
                }
              }, 50);
              
              // For space key, prepare to chain commands
              if (e.key === ' ') {
                // Prevent default space bar scrolling
                e.preventDefault();
                
                // Auto-append a '+' to chain with previous command if the field is empty
                if (prompt.value.trim() === '' && lastCommandExecuted) {
                  prompt.value = '+';  // Chain command indicator
                }
              } else {
                e.preventDefault();
              }
            }
          }
        });
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            let command = input.value.trim();
            if (command) {
              // Process command chaining using + symbol
              if (command.startsWith('+') && lastCommandExecuted) {
                // Get frequency and duration from last command
                let parts = lastCommandExecuted.match(/^s(\d+)\s*(\d*)/);
                if (parts) {
                  let lastFreq = parts[1];
                  // Replace + with the actual command
                  command = command.replace('+', 's' + lastFreq + ' ');
                }
              }
              
              // Add to history and reset index
              commandHistory.unshift(command);
              historyIndex = -1;
              
              // Execute command but keep input focused for rapid input
              evaluateCommand(command);
              
              // Don't clear input if holding shift (for rapid command chains)
              if (!e.shiftKey) {
                input.value = '';
              } else {
                input.value = '+';
                input.select();
              }
              
              // Ensure prompt stays active for next command
              setTimeout(() => input.focus(), 50);
            }
          } else if (e.key === 'ArrowUp') {
            if (historyIndex < commandHistory.length - 1) {
              historyIndex++;
              input.value = commandHistory[historyIndex];
            }
          } else if (e.key === 'ArrowDown') {
            if (historyIndex > -1) {
              historyIndex--;
              input.value = historyIndex === -1 ? '' : commandHistory[historyIndex];
            }
          } else if (e.key === 'Tab') {
            // Quick command chaining with Tab key
            e.preventDefault();
            if (lastCommandExecuted) {
              input.value = '+';
            }
          }
        });
      }
      
      document.getElementById('conductorControls').style.display = audioStarted && role === 'conductor' ? 'block' : 'none';
    }
    
    // Update active timers and their countdowns
    function updateTimers() {
      // Update window timer if active
      if (activeTimers.window) {
        const now = Date.now();
        const remaining = Math.max(0, activeTimers.window.endTime - now);
        
        if (remaining <= 0) {
          // Window timer expired
          activeTimers.window = null;
        } else {
          // Update countdown (in seconds, one decimal place)
          activeTimers.window.remaining = Math.round(remaining / 100) / 10;
        }
      }
      
      // Update individual event timers
      activeTimers.events = activeTimers.events.filter(timer => {
        const now = Date.now();
        const remaining = Math.max(0, timer.endTime - now);
        
        if (remaining <= 0) {
          // Timer expired, remove it
          return false;
        } else {
          // Update countdown (in seconds, one decimal place)
          timer.remaining = Math.round(remaining / 100) / 10;
          return true;
        }
      });
      
      // Update HUD if any timers are active
      if (activeTimers.window || activeTimers.events.length > 0) {
        updateHUD();
      }
    }
    
    // --- Keyboard Shortcuts: Ctrl+C for conductor, Alt+X/F for panic ---
    document.addEventListener('keydown', function(e) {
      // Only trigger if not typing in an input/textarea
      const active = document.activeElement;
      const isInputActive = active.tagName === 'INPUT' || active.tagName === 'TEXTAREA';
      if (isInputActive) return;
      
      // Ctrl+X for immediate panic (stop all sounds and clear all timers)
      if (!isInputActive && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'x') {
        e.preventDefault();
        console.log('🛑 PANIC STOP - Stopping all audio and clearing timers');
        
        socket.emit('panic', { type: 'stop', from: clientId });
        return;
      }
      
      // Ctrl+F for fade-out panic (gradually fade out all sounds)
      if (!isInputActive && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        console.log('🔉 PANIC FADE - Fading out all audio');
        
        socket.emit('panic', { type: 'fade', from: clientId });
        return;
      }
      
      // Ctrl+Shift+H for toggling HUD visibility
      if (!isInputActive && e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'h') {
        e.preventDefault();
        console.log('👁️ Toggling HUD visibility');
        toggleHudVisibility();
        return;
      }
      
      // Ctrl+C becomes conductor
      if (!isInputActive && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
        e.preventDefault();
        socket.emit('requestConductor');
        messages[clientId] = 'Requested conductor role (via Ctrl+C)';
        updateHUD();
        return;
      }
      
      // Ctrl+X for immediate panic (stop all sounds and clear all timers)
      if (!isInputActive && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'x') {
        e.preventDefault();
        console.log('🛑 PANIC STOP - Stopping all audio and clearing timers');
        
        // Broadcast panic stop to all performers
        socket.emit('panic', { type: 'stop', from: clientId, timestamp: Date.now() });
        
        // Terminate all audio locally
        if (typeof Tone !== 'undefined') {
          Tone.Transport.cancel();
          Tone.Transport.stop();
          if (typeof Tone.getDestination === 'function') {
            Tone.getDestination().mute = true;
            setTimeout(() => Tone.getDestination().mute = false, 50);
          }
          // Force dispose any lingering synths
          if (sweepFilter) sweepFilter.dispose();
          sweepFilter = new Tone.Filter({
            frequency: 2000,
            type: "lowpass",
            rolloff: -12
          }).toDestination();
        }
        
        // Terminate all timers
        activeTimers.window = null;
        activeTimers.events = [];
        
        messages[clientId] = '🛑 PANIC STOP! (Ctrl+X)';
        updateHUD();
        return;
      }
      
      // Ctrl+F for 6-second fadeout panic and clear timers when fade completes
      if (!isInputField && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
        e.preventDefault();
        console.log('🔇 PANIC FADE - 6 second fadeout');
        
        // Broadcast panic fade to all performers
        socket.emit('panic', { type: 'fade', duration: 6000, from: clientId, timestamp: Date.now() });
        
        if (typeof Tone !== 'undefined' && typeof Tone.getDestination === 'function') {
          const dest = Tone.getDestination();
          const originalVolume = dest.volume.value;
          const fadeSteps = 60;
          const fadeTime = 6000; // 6 seconds
          const interval = fadeTime / fadeSteps;
          let step = 0;
          
          // Fade out gradually
          const fadeInterval = setInterval(() => {
            step++;
            if (step >= fadeSteps) {
              clearInterval(fadeInterval);
              dest.volume.value = originalVolume; // Reset for future sounds
              Tone.Transport.cancel();
              Tone.Transport.stop();
              // Force dispose any lingering synths
              if (sweepFilter) sweepFilter.dispose();
              sweepFilter = new Tone.Filter({
                frequency: 2000,
                type: "lowpass",
                rolloff: -12
              }).toDestination();
              
              // Clear all timers at the end of fade out
              activeTimers.window = null;
              activeTimers.events = [];
              updateHUD(); // Update HUD to reflect cleared timers
              
              // Update message to indicate fade completed
              messages[clientId] = '🔇 FADE COMPLETED - All timers cleared';
              updateHUD();
            } else {
              // Exponential fadeout curve feels more natural
              const fraction = 1 - (step / fadeSteps);
              const newVolume = originalVolume - (60 * (1 - Math.pow(fraction, 3)));
              dest.volume.value = newVolume;
            }
          }, interval);
          
          messages[clientId] = '🔇 PANIC FADE (6s) (Ctrl+F)';
          updateHUD();
        }
        return;
      }
    });
    // --- Centralized Command Parsing Integration ---
    function evaluateCommand(command) {
      console.log('evaluateCommand:', command);
      lastCommand = command;
      
      // For polyphonic sound generation - track successful command execution
      // This will be used for command chaining with '+'  
      lastCommandExecuted = command;
      
      // Basic validation
      if (!command || typeof command !== 'string') return;
      
      const trimmedCommand = command.trim();
      console.log(`[command] Evaluating: "${trimmedCommand}"`);

      // Centralized command parsing
      const parsed = parseCommand(trimmedCommand);
      if (parsed) {
        if (parsed.generator === 's') {
          processSineCommand(parsed.freq, parsed.dur);
          return;
        } else if (parsed.generator === 'sf') {
          if (role === 'conductor') {
            pendingVisualPulses.push(performance.now());
            
            // Create timers for display
            const now = Date.now();
            
            // Track individual event duration
            const eventDuration = parsed.dur * 1000; // Convert to milliseconds
            
            // Add event timer
            activeTimers.events.push({
              type: 'event',
              duration: parsed.dur,
              endTime: now + eventDuration,
              remaining: parsed.dur
            });
            
            // Track window duration if specified
            if (parsed.window) {
              const windowDuration = parsed.window * 1000; // Convert to milliseconds
              
              // Set window timer (replace any existing one)
              activeTimers.window = {
                type: 'window',
                duration: parsed.window,
                endTime: now + windowDuration,
                remaining: parsed.window
              };
            }
            
            socket.emit('generator', { type: 'sf', ...parsed, timestamp: Date.now() });
            messages[clientId] = `Sent ${trimmedCommand} to all clients`;
            updateHUD();
            
            // Play locally for conductor
            if (audioStarted && typeof runSfGenerator === 'function') {
              runSfGenerator({ ...parsed, onTrigger: playGeneratorSound });
            }
          } else {
            messages[clientId] = 'Only conductor can send sf commands';
            updateHUD();
          }
          return;
        }
        // Add more generator types here as needed
      }

      // Audio status command
      if (trimmedCommand.toLowerCase() === 'audiostatus') {
        console.log('[command] Checking audio status');
        displayAudioStatus();
        return;
      }

      // Other commands (freq, circle, etc)
      let parts = trimmedCommand.split(' ');
      if (parts[0] === 'freq' && parts[1]) {
        let freq = parseFloat(parts[1]);
        if (!isNaN(freq)) {
          sendControl({ type: 'freq', value: freq });
        }
      } else if (parts[0] === 'circle') {
        let clientIds = Object.keys(clients);
        clientIds.forEach((id, index) => {
          setTimeout(() => {
            if (clients[id].role === 'performer') {
              sendControl({ type: 'freq', value: 200 + (index * 100), target: id });
            }
          }, index * 500);
        });
      } else {
        console.log(`[command] Unknown command: ${trimmedCommand}`);
        messages[clientId] = `Unknown command: ${trimmedCommand}`;
        updateHUD();
      }
    }
    // Helper function to process sine commands
    function processSineCommand(freq, dur) {
      if (role === 'conductor') {
        // Visual feedback that command was received
        pendingVisualPulses.push(performance.now());
        
        // Send to all clients via the server
        socket.emit('generator', { type: 'sine', freq, dur, timestamp: Date.now() });
        console.log(`[sine] Sent sine: ${freq}Hz for ${dur}s to all`);
        messages[clientId] = `Sent s${freq}^${dur} to all clients`;
        updateHUD();
        
        // Also play locally for the conductor
        if (audioStarted) {
          if (!synth) synth = new Tone.Synth().connect(sweepFilter);
          try {
            synth.triggerAttackRelease(freq, dur);
            console.log(`[sine] Conductor local playback: ${freq}Hz for ${dur}s`);
          } catch (err) {
            console.error('Error playing conductor local sound:', err);
          }
        } else {
          console.warn('Audio not started for conductor');
          // Try to start audio
          Tone.start().then(() => {
            audioStarted = true;
            if (!synth) synth = new Tone.Synth().connect(sweepFilter);
            synth.triggerAttackRelease(freq, dur);
            console.log('Started audio and played sound');
            updateHUD();
          }).catch(err => console.error('Failed to start audio:', err));
        }
      } else {
        console.log(`[command] Not a conductor, can't broadcast commands`);
      }
    }
    

    

    // error boundary
    window.onerror = function(msg, url, lineNo, columnNo, error) {
      console.log(`error: ${msg} at ${url}:${lineNo}`);
        return false;
      };
    // HUD visibility toggle function
    function toggleHudVisibility() {
      hudVisible = !hudVisible;
      
      // Elements to toggle
      const hudElements = [
        document.getElementById('hud'),
        document.getElementById('performers-hud')
      ];
      
      // Toggle visibility for each element
      hudElements.forEach(el => {
        if (el) {
          el.style.display = hudVisible ? 'block' : 'none';
        }
      });
      
      // Show brief message
      if (hudVisible) {
        messages[clientId] = 'HUD elements visible';
      } else {
        messages[clientId] = 'HUD hidden (press Ctrl+Shift+H to restore)';
        // Brief flash message then clear it
        setTimeout(() => {
          if (!hudVisible) {
            messages[clientId] = '';
            updateHUD();
          }
        }, 2000);
      }
      
      updateHUD();
    }
    
    // README modal functions
    function toggleReadmeModal() {
      console.log('toggleReadmeModal called');
      const modal = document.getElementById('readmeModal');
      console.log('Modal element:', modal);
      
      if (modal) {
        // Force display to be explicitly set either way
        if (modal.style.display === 'block') {
          console.log('Modal is currently visible, hiding it');
          modal.style.display = 'none';
        } else {
          console.log('Modal is currently hidden, showing it');
          modal.style.display = 'block';
          populateReadmeContent();
        }
      } else {
        console.error('README modal element not found!');
      }
    }
    
    function openReadmeModal() {
      const modal = document.getElementById('readmeModal');
      if (modal) {
        modal.style.display = 'block';
        populateReadmeContent();
      }
    }
    
    function closeReadmeModal() {
      const modal = document.getElementById('readmeModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }
    
    // Populate README content from README.md
    function populateReadmeContent() {
      const contentDiv = document.getElementById('readmeContent');
      if (!contentDiv) return;
      
      // Add formatted README content
      contentDiv.innerHTML = `
        <h1>Trawun</h1>
        
        <p>Trawun is a networked real-time music performance system designed for distributed cognition and collaborative sound synthesis. It uses WebSockets to connect multiple performers together, each contributing to a shared sonic environment through a minimalist text-based syntax called SYNO.</p>
        
        <h2>System Architecture</h2>
        
        <p>Built on a client-server architecture using:</p>
        
        <ul>
          <li><strong>Backend</strong>: Express.js with Socket.io for real-time communication</li>
          <li><strong>Frontend</strong>: HTML5, JavaScript with Tone.js for audio synthesis and p5.js for visualization</li>
          <li><strong>Communication Protocol</strong>: WebSockets via Socket.io</li>
          <li><strong>Sound Engine</strong>: Tone.js for real-time audio synthesis and processing</li>
        </ul>
        
        <h3>Core Design Patterns</h3>
        
        <p>The architecture follows several key design patterns:</p>
        
        <ul>
          <li><strong>Observer Pattern</strong>: The renderer listens to audio state changes and updates the UI</li>
          <li><strong>Composite Pattern</strong>: The audio system walks the AST node tree for sound generation</li>
          <li><strong>Factory Method</strong>: Creates audio nodes from parsed SYNO commands</li>
          <li><strong>Command Pattern</strong>: Schedules parameter transitions as commands</li>
          <li><strong>Facade Pattern</strong>: Main entry point orchestrates parser, audio, and renderer modules</li>
        </ul>
        
        <h2>SYNO Language Reference</h2>
        
        <p>SYNO is a terse, energy-efficient language designed for live coding music. It emphasizes minimalism while allowing complex sound generation and manipulation.</p>
        
        <h3>Syntax Philosophy</h3>
        
        <ul>
          <li><strong>Characters</strong>: Generators and processors</li>
          <li><strong>Numbers</strong>: Parameter values</li>
          <li><strong>Parentheses</strong>: Nested operations</li>
          <li><strong>Order-Independence</strong>: Parameter order doesn't matter (e.g., <code>sf100-500v1p?</code> = <code>sf100-500p?v1</code>)</li>
        </ul>
        
        <h3>Sound Generators</h3>
        
        <h4>Basic Sine Wave (<code>s</code>)</h4>
        
        <pre><code>s                    # 220 Hz sine wave, default duration
s440                 # 440 Hz sine wave
s220^2               # 220 Hz sine for 2 seconds
s100>300'10         # Sweep 100 to 300 Hz in 10 seconds
s440v5              # 440 Hz sine at volume 5
s440p1              # 440 Hz sine panned right</code></pre>
        
        <h4>Sine Fade Cloud (<code>sf</code>)</h4>
        
        <pre><code>sf                   # Default sine fade cloud (20-440Hz range, 5 tones, 10s window)
sf100-500            # Random frequencies between 100-500Hz
sf100-500^1*5v1)^10 # 5 tones between 100-500Hz, each 1s, spread over 10s window, volume 1
sf20-440^1*5v1p?    # Same but with random panning</code></pre>
      `;
      
      // Initialize modal events
      initModalEvents();
    }
    
    function initModalEvents() {
      // Close button event
      const closeBtn = document.querySelector('.modal-close');
      if (closeBtn) {
        closeBtn.onclick = closeReadmeModal;
      }
      
      // Click outside modal to close
      const modal = document.getElementById('readmeModal');
      if (modal) {
        modal.onclick = function(event) {
          if (event.target === modal) {
            closeReadmeModal();
          }
        };
      }
      
      // ESC key to close modal
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          closeReadmeModal();
        }
      });
    }
    
    // Initialize when page loads
    window.addEventListener('DOMContentLoaded', function() {
      // Initialize modal events
      initModalEvents();
      
      // Update document title with version
      document.title = `trawun v${TRAWUN_VERSION}`;
      
      // Update modal title with version
      const modalTitle = document.querySelector('.modal-content h1');
      if (modalTitle) {
        modalTitle.textContent = `trawun v${TRAWUN_VERSION}`;
      }
    });
    
    // Ensure all script blocks are closed
    </script>

    <script>
/* ==== Sweep Filter Controlled by Device Rotation ==== */

// --- Config ---
const minFreq = 200, maxFreq = 2000; // Filter sweep range (Hz)
let sensorsEnabled = false;

// --- Create a filter and connect to master output ---
const sweepFilter = new Tone.Filter(minFreq, "lowpass").toDestination();

// --- HUD for debugging ---
const hud = document.createElement("div");
Object.assign(hud.style, {
  position: "fixed", top: "10px", left: "10px",
  color: "lightgray", fontSize: "1.1em", fontFamily: "monospace",
  background: "rgba(0, 0, 0, 0.5)", padding: "5px 10px", borderRadius: "5px",
  zIndex: "1000", pointerEvents: "none"
});
document.body.appendChild(hud);

// --- Permission Request ---
async function requestSensorPermissions() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    try {
      const permissionState = await DeviceMotionEvent.requestPermission();
      if (permissionState === "granted") sensorsEnabled = true;
      else console.error("Sensor access denied");
    } catch (e) { console.error("Sensor permission error", e); }
  } else {
    sensorsEnabled = true;
  }
  await Tone.start();
  console.log("AudioContext started, sensorsEnabled:", sensorsEnabled);
}

// --- Orientation Handler ---
let rotX = 0, rotY = 0, rotZ = 0, initialBeta = null;
function orientationHandler(event) {
  if (!sensorsEnabled) return;
  // Use beta (front-back tilt) for sweep
  if (initialBeta === null) initialBeta = event.beta || 0;
  rotX = event.beta || 0;
  rotY = event.gamma || 0;
  rotZ = event.alpha || 0;
  // Map beta (rotX) from initialBeta±45° to minFreq-maxFreq
  let sweep = Math.max(-45, Math.min(45, rotX - initialBeta));
  let freq = minFreq + ((sweep + 45) / 90) * (maxFreq - minFreq);
  sweepFilter.frequency.rampTo(freq, 0.1);
  // HUD
  hud.innerHTML = `rotX (beta): ${rotX.toFixed(1)}<br>Filter freq: ${freq.toFixed(1)} Hz`;
}

// --- Enable on user gesture ---
document.body.addEventListener("touchend", async () => {
  if (!sensorsEnabled) {
    await requestSensorPermissions();
    if (sensorsEnabled) {
      window.addEventListener("deviceorientation", orientationHandler, false);
      console.log("Sweep filter sensor control enabled!");
    }
  }
});
// Also allow desktop click for testing
document.body.addEventListener("click", async () => {
  if (!sensorsEnabled) {
    await requestSensorPermissions();
    if (sensorsEnabled) {
      window.addEventListener("deviceorientation", orientationHandler, false);
      console.log("Sweep filter sensor control enabled!");
    }
  }
});
</script>
  </body>
</html>