
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>musical app</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono&display=swap" rel="stylesheet">
  <script src="parsers/commandParser.js"></script>
  <script src="generators/sineGenerator.js"></script>

  <style>
    body {
      margin: 0;
      font-family: 'IBM Plex Mono', monospace;
      overflow: hidden;
    }
    .vumeter {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 3;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1;
    }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 2;
      text-align: left;
    }
    button {
      padding: 10px;
      margin: 5px;
      font-family: 'IBM Plex Mono', monospace;
      background: rgba(0, 0, 0, 0.7);
      color: #00ff00;
      border: 1px solid #00ff00;
      cursor: pointer;
      touch-action: manipulation;
    }
    #hud {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #00ff00;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 14px;
      padding: 10px;
      z-index: 2;
      max-width: 400px;
      white-space: pre;
      text-transform: lowercase;
    }
    #performers-hud {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #00ff00;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 14px;
      padding: 10px;
      z-index: 2;
      max-width: 400px;
      white-space: pre;
      text-transform: lowercase;
      text-align: right;
    }
    #commandPrompt {
      width: 100%;
      padding: 5px;
      margin-top: 10px;
      background: rgba(200, 162, 200, 0.2); /* lilac */
      color: #4169e1; /* blue */
      border: 1px solid #4169e1;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 14px;
    }
    #commandPrompt:focus {
      outline: none;
      border-color: #c8a2c8;
    }
    #console {
      max-height: 100px;
      overflow-y: auto;
      margin-top: 10px;
      font-size: 12px;
      color: #D4A5A5; /* soft pink */
    }
    .client-data {
      opacity: 0.3;
    }
    #requestConductor {
      position: absolute;
      left: 0;
    }
     #commandPrompt {
      width: 100%;
      padding: 5px;
      margin-top: 10px;
      background: none;
      color: #8fedf0; /* Blue */
      border: 0px none;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 14px;
    }
</style>
</head>
<body>
  <div id="controls">
    <div id="conductorControls" style="display:none;">
    </div>
    <!-- Transparent Start Audio Overlay (with QR placeholder) -->
    <div id="startAudioOverlay" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1000;background:#000;display:flex;align-items:center;justify-content:center;cursor:pointer;">
  <div style="display:flex;flex-direction:column;align-items:center;">
    <img src="qr.png" alt="QR code" style="width:180px;height:180px;object-fit:contain;margin-bottom:24px;filter:drop-shadow(0 0 8px #fff);background:#fff;border-radius:16px;" />
    <span style="color:#fff;font-size:24px;">tap anywhere to start audio</span>
  </div>
</div>
  </div>
  <div id="hud">initializing...</div>
  <div id="performers-hud"></div>
  <script>
// ---- Inlined SineCirclePhysics ----
class SineCirclePhysics {
  constructor(baseRadius = 60) {
    this.N = 120;
    this.baseRadius = baseRadius;
    this.center = { x: 0, y: 0 };
    this.modes = [];
    this.electricModes = [];
    this.t = 0;
    this.perturbationIndex = 0.1; // 0 = none, 1 = max
    this.startTime = null;
    this.envAmt = 0;
    this.decayAmt = 0;
    this._initModes();
  }
  _initModes() {
    let modeNumbers = [2, 3, 5, 6];
    for (let n of modeNumbers) {
      this.modes.push({
        n,
        baseAmp: 0,
        amp: 0,
        phase: Math.random() * Math.PI * 2,
        speed: Math.random() * 2 + 1.5
      });
    }
    let electricNumbers = [13, 17, 23];
    for (let n of electricNumbers) {
      this.electricModes.push({
        n,
        amp: 0.8,
        speed: Math.random() * 15 + 15,
        phase: Math.random() * Math.PI * 2
      });
    }
  }
  trigger(nowMillis) {
    this.startTime = nowMillis || (typeof millis === 'function' ? millis() : Date.now());
    for (let m of this.modes) {
      m.baseAmp = Math.random() * 10 + 5;
      m.phase = Math.random() * Math.PI * 2;
    }
    for (let em of this.electricModes) {
      em.phase = Math.random() * Math.PI * 2;
    }
  }
  update(nowMillis) {
    this.t += 0.04;
    if (this.startTime !== null) {
      let elapsed = (nowMillis || (typeof millis === 'function' ? millis() : Date.now())) - this.startTime;
      if (elapsed < 300) {
        let pct = Math.max(0, Math.min(1, elapsed / 300));
        this.envAmt = Math.pow(pct, 2.2);
      } else if (elapsed < 500) {
        this.envAmt = 1;
      } else if (elapsed < 1000) {
        this.envAmt = this._map(elapsed, 500, 1000, 1, 0);
      } else {
        this.envAmt = 0;
      }
      this.decayAmt = Math.exp(-0.0025 * elapsed);
    } else {
      this.envAmt = 0;
      this.decayAmt = 0;
    }
  }
  getShapePoints(centerX, centerY) {
    let points = [];
    for (let i = 0; i < this.N; i++) {
      let angle = (Math.PI * 2) * i / this.N;
      let r = this.baseRadius;
      for (let m of this.modes) {
        let jitter = Math.sin(m.n * angle + m.phase + this.t * m.speed);
        let amp = m.baseAmp * (0.4 * this.envAmt + 0.6 * this.decayAmt);
        r += amp * this.perturbationIndex * jitter;
      }
      for (let em of this.electricModes) {
        let buzz = Math.sin(em.n * angle + em.phase + this.t * em.speed);
        r += buzz * em.amp * this.envAmt * this.perturbationIndex;
      }
      let x = centerX + r * Math.cos(angle);
      let y = centerY + r * Math.sin(angle);
      points.push({ x, y });
    }
    return points;
  }
  _map(val, a, b, c, d) {
    return c + (d - c) * ((val - a) / (b - a));
  }
}
// ---- End Inlined SineCirclePhysics ----
    let socket = io();
    let synth = null;
let meterAnalyser = null;
let meterDataArray = null;
let meterLevel = 0;
    let clientId, clientName, role, clients = {};
    let audioStarted = false;
    let commandHistory = [];
    let historyIndex = -1;
    let messages = {};
    // --- Pulse Visuals ---
    let pendingVisualPulses = [];
    let lastPulseTime = 0;
    let pulseActive = false;
    let pulseAlpha = 0;
    // --- End Pulse Visuals ---
    
    // initialize tone.js synth
    // --- Start Audio Overlay Logic ---
    async function startAudioOverlayHandler(e) {
  // Always hide overlay on first tap, regardless of Tone.js status
  if (e) e.stopPropagation();
  const overlay = document.getElementById('startAudioOverlay');
  if (overlay) overlay.style.display = 'none';
  
  if (typeof Tone !== 'undefined') {
    try {
      // On iOS/Safari we need user interaction for audio to work
      if (/iPhone|iPad|iPod|Safari/i.test(navigator.userAgent) && !audioStarted) {
        console.log('iOS/Safari detected, ensuring audio context starts...');
      }
      
      // Ensure we await the Tone.start() call to properly initialize audio context
      await Tone.start();
      audioStarted = true;
      console.log('Audio context started:', Tone.context.state);
      
      // Initialize synth immediately to avoid potential issues
      if (!synth) {
        synth = new Tone.Synth().connect(sweepFilter);
        console.log('Synth initialized');
        
        // Play a short test tone to confirm audio is working
        // Use lower volume for test tone to avoid startling users
        const testVol = new Tone.Volume(-20).toDestination();
        const testSynth = new Tone.Synth().connect(testVol);
        testSynth.triggerAttackRelease('C4', 0.1);
        console.log('Test tone played');
        
        // Also try playing a sine wave to ensure the audio system is fully activated
        setTimeout(() => {
          if (synth) {
            console.log('Playing additional test tone after 500ms...');
            synth.triggerAttackRelease(880, 0.05);
          }
        }, 500);
      }
      
      // Create a visual pulse to show audio is working
      pendingVisualPulses.push(performance.now());
      
      // Update HUD to reflect audio status
      updateHUD();
    } catch (err) {
      console.error('Error starting audio context:', err);
      // Try to show error in HUD
      const hud = document.getElementById('hud');
      if (hud) {
        hud.innerHTML += `<div style="color:red">Audio error: ${err.message}</div>`;
      }
    }
  } else {
    console.error('Tone.js not available!');
  }
}
    window.addEventListener('DOMContentLoaded', () => {
      const overlay = document.getElementById('startAudioOverlay');
      if (overlay) {
        const startAudio = () => {
          if (typeof Tone !== 'undefined' && Tone.context && Tone.context.state !== 'running') {
            Tone.start().then(() => {
              audioStarted = true;
              console.log('[overlay] Audio resumed via Tone.start()');
            });
          } else {
            audioStarted = true;
          }
        };
        overlay.addEventListener('click', (e) => { startAudio(); startAudioOverlayHandler(e); });
        overlay.addEventListener('touchstart', (e) => { startAudio(); startAudioOverlayHandler(e); });
      }
    });
    // --- End Start Audio Overlay Logic ---
    
    // p5.js setup
    function setup() {
      createCanvas(windowWidth, windowHeight);
      windowResized();
      // Crear analyser para el master output
      if (typeof Tone !== 'undefined' && Tone.Destination && !meterAnalyser) {
        meterAnalyser = Tone.context.createAnalyser();
        meterAnalyser.fftSize = 256;
        meterDataArray = new Uint8Array(meterAnalyser.fftSize);
        // Conectar analyser al master (API Tone.js >=14)
        if (typeof Tone.Destination.connect === 'function') {
          Tone.Destination.connect(meterAnalyser);
        } else if (Tone.Destination.node && typeof Tone.Destination.node.connect === 'function') {
          Tone.Destination.node.connect(meterAnalyser);
        }
      }
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
    
    function draw() {
  // --- Pulse Visuals ---
  const now = performance.now();
  // Remove and trigger any pulses due now
  while (pendingVisualPulses.length && pendingVisualPulses[0] <= now) {
    lastPulseTime = now;
    pulseActive = true;
    pulseAlpha = 255; // full brightness
    pendingVisualPulses.shift();
  }
  // Draw the pulse visual if active
  if (pulseActive) {
    fill(255, pulseAlpha);
    noStroke();
    ellipse(width / 2, height / 2, 200, 200); // expanding circle
    pulseAlpha -= 10; // fade out
    if (pulseAlpha <= 0) {
      pulseActive = false;
    }
  }
  // --- End Pulse Visuals ---
  background(0);
  for (let id in clients) {
    let c = clients[id];
    
    // Asegurarse de que las propiedades de posición actual existen
    if (c && c.position && typeof c.position.xNorm === 'number' && typeof c.position.yNorm === 'number') {
      // Si no hay posición interpolada, inicializarla
      if (!c.interpolatedPos) {
        c.interpolatedPos = {
          x: c.position.xNorm * windowWidth,
          y: c.position.yNorm * windowHeight
        };
        c.fromPos = { ...c.interpolatedPos };
        c.toPos = { ...c.interpolatedPos };
        c.moveStartTime = millis ? millis() : Date.now();
      }
      
      // Calcular posición objetivo
      let targetX = c.position.xNorm * windowWidth;
      let targetY = c.position.yNorm * windowHeight;
      
      // Timer-based interpolation with 300ms transitions (smooth but responsive)
      const duration = 300; // ms - quick transitions for better responsiveness
      let now = millis ? millis() : Date.now();
      if ((Math.abs(c.toPos.x - targetX) > 1) || (Math.abs(c.toPos.y - targetY) > 1)) {
        // New target detected, start new transition
        c.fromPos = { x: c.interpolatedPos.x, y: c.interpolatedPos.y };
        c.toPos = { x: targetX, y: targetY };
        c.moveStartTime = now;
      }
      // Apply easeOutCubic easing for smoother motion
      let t = constrain((now - c.moveStartTime) / duration, 0, 1);
      let easing = 1 - Math.pow(1 - t, 3); // easeOutCubic for smoother transitions
      c.interpolatedPos.x = lerp(c.fromPos.x, c.toPos.x, easing);
      c.interpolatedPos.y = lerp(c.fromPos.y, c.toPos.y, easing);
      
      // --- VU meter color for border ---
      let vuAlpha = map(meterLevel, 0, 1, 80, 255);
      let vuR = meterLevel > 0.5 ? 255 : Math.floor(255 * (meterLevel * 2));
      let vuG = meterLevel > 0.5 ? Math.floor(255 * (2 - meterLevel * 2)) : 255;
      let vuColor = color(vuR, vuG, 0, vuAlpha);
      
      // --- Wireframe/Idle: transparent fill, ID color border ---
      if (c.physics && typeof c.physics.update === 'function') {
        // Generator active: border = VU meter, fill transparent
        noFill();
        c.physics.update();
        let pts = c.physics.getShapePoints(c.interpolatedPos.x, c.interpolatedPos.y);
        stroke(vuColor);
        strokeWeight(4 + meterLevel * 8);
        drawingContext.shadowBlur = 24 * meterLevel;
        drawingContext.shadowColor = `rgba(${vuR},${vuG},0,${meterLevel})`;
        beginShape();
        for (let pt of pts) vertex(pt.x, pt.y);
        endShape(CLOSE);
        drawingContext.shadowBlur = 0;
      } else {
        // Idle: border = ID color, fill transparent
        noFill();
        stroke((c && c.color) ? c.color : '#3498DB');
        strokeWeight(4);
        drawingContext.shadowBlur = 0;
        
        // Handle role-based circle size with transitions
        const conductorSize = 100;
        const performerSize = 60;
        const targetSize = c.role === 'conductor' ? conductorSize : performerSize;
        
        // Initialize size tracking if not exists
        if (c.currentSize === undefined) {
          c.currentSize = targetSize;
          c.fromSize = targetSize;
          c.toSize = targetSize;
          c.sizeChangeTime = now;
        }
        
        // Check if role changed (target size changed)
        if (Math.abs(c.toSize - targetSize) > 1) {
          // Start size transition
          c.fromSize = c.currentSize;
          c.toSize = targetSize;
          c.sizeChangeTime = now;
          console.log(`Role transition for ${id}: ${c.role} (${c.fromSize} → ${c.toSize})`);
        }
        
        // Animate size over 500ms with easeOutCubic
        const sizeDuration = 500; // ms
        let sizeT = constrain((now - c.sizeChangeTime) / sizeDuration, 0, 1);
        let sizeEasing = 1 - Math.pow(1 - sizeT, 3); // easeOutCubic
        c.currentSize = lerp(c.fromSize, c.toSize, sizeEasing);
        
        // Draw the circle with current interpolated size
        ellipse(
          c.interpolatedPos.x,
          c.interpolatedPos.y,
          c.currentSize,
          c.currentSize
        );
      }
      
      // Dibujar línea entre posición actual y objetivo si están lejos
      let distance = dist(c.interpolatedPos.x, c.interpolatedPos.y, targetX, targetY);
      if (distance > 5) {
        stroke(c.color || '#3498DB');
        strokeWeight(1);
        line(c.interpolatedPos.x, c.interpolatedPos.y, targetX, targetY);
        noStroke();
      }
    }
  }
  
  // Draw VU meter horizontal bar at bottom
  drawVUMeter();
}

// Draws a horizontal VU meter at the bottom of the screen
function drawVUMeter() {
  if (meterAnalyser && meterDataArray) {
    // Get current audio levels
    meterAnalyser.getByteFrequencyData(meterDataArray);
    
    // Calculate average level
    let sum = 0;
    for (let i = 0; i < meterDataArray.length; i++) {
      sum += meterDataArray[i];
    }
    const average = sum / meterDataArray.length;
    
    // Convert to dB scale (approximation)
    const dB = 20 * Math.log10(average / 255 + 1e-10);
    const level = Math.max(0, Math.min(1, (dB + 60) / 60)); // Normalize between 0 and 1
    
    // Draw meter background
    noStroke();
    fill(0, 0, 0, 180);
    rect(0, height - 4, width, 4); // Increased height to 4px for better visibility
    
    // Draw meter level with color based on level
    const meterWidth = width * level;
    // Color gradient from green to yellow to red based on level
    let r = level > 0.5 ? 255 : Math.floor(255 * (level * 2));
    let g = level > 0.5 ? Math.floor(255 * (2 - level * 2)) : 255;
    fill(r, g, 0);
    rect(0, height - 4, meterWidth, 4);
    
    // Add digital readout for debugging
    if (level > 0.01) {
      fill(255);
      textSize(10);
      textAlign(LEFT);
      text(`${dB.toFixed(1)} dB`, 5, height - 8);
    }
    
    // Update global meter level for other components to use
    meterLevel = level;
    
    // Log audio level to console periodically (roughly once per second)
    if (frameCount % 60 === 0 && level > 0.01) {
      console.log(`[Audio Level] ${dB.toFixed(1)} dB, normalized: ${level.toFixed(3)}`);
    }
  }
}
    
    // manual position update
    let lastPositionUpdate = 0;
    function updatePosition(x, y) {
      // Verificar que las coordenadas son válidas
      if (isNaN(x) || isNaN(y) || x === undefined || y === undefined) {
        console.error('[updatePosition] Coordenadas inválidas:', x, y);
        return;
      }
      
      let xNorm = constrain(x / windowWidth, 0, 1);
      let yNorm = constrain(y / windowHeight, 0, 1);
      console.log('[updatePosition] input:', x, y, 'normalized:', xNorm, yNorm, 'window:', windowWidth, windowHeight);
      
      // Límite de frecuencia de actualización para evitar saturar la red
      if (Date.now() - lastPositionUpdate > 50) { // Actualización cada 50ms máximo
        lastPositionUpdate = Date.now();
        
        // Verificar que el cliente existe
        if (!clients[clientId]) {
          console.warn('[updatePosition] Cliente no existe:', clientId);
          return;
        }
        
        // Actualizar posición localmente
        clients[clientId].position = { xNorm, yNorm };
        
        // Siempre enviar la posición al servidor, sin importar audioStarted
        let locationMsg = `${clientName}/room/${xNorm.toFixed(2)}/${yNorm.toFixed(2)}`;
        socket.emit('location', locationMsg);
        messages[clientId] = locationMsg;
        console.log(`position updated: x=${x}, y=${y}, xNorm=${xNorm.toFixed(2)}, yNorm=${yNorm.toFixed(2)}`);
        
        // Crear un pulso visual para indicar la actualización de posición
        pendingVisualPulses.push(performance.now());
        
        updateHUD();
      }
    }
    
    // Test audio system functionality
    function testAudioSystem() {
      if (!audioStarted) {
        console.warn('Audio not started yet. Attempting to start...');
        Tone.start().then(() => {
          audioStarted = true;
          runAudioTest();
        }).catch(err => {
          console.error('Failed to start audio in test:', err);
          messages[clientId] = 'Error: ' + err.message;
          updateHUD();
        });
      } else {
        runAudioTest();
      }
    }
    
    function runAudioTest() {
      console.log('Running audio test sequence...');
      messages[clientId] = 'Testing audio...';
      updateHUD();
      
      // Make sure synth is initialized
      if (!synth) synth = new Tone.Synth().connect(sweepFilter);
      
      // Play a scale of notes
      const testNotes = ['C4', 'E4', 'G4', 'C5'];
      const interval = 0.2;
      
      testNotes.forEach((note, i) => {
        setTimeout(() => {
          synth.triggerAttackRelease(note, 0.1);
          console.log(`Test note ${i+1}/${testNotes.length}: ${note}`);
          // Visual feedback
          pendingVisualPulses.push(performance.now());
          if (i === testNotes.length - 1) {
            messages[clientId] = 'Audio test complete';
            updateHUD();
            setTimeout(() => {
              if (messages[clientId] === 'Audio test complete') {
                messages[clientId] = '';
                updateHUD();
              }
            }, 2000);
          }
        }, i * interval * 1000);
      });
    }
    
    // Display detailed audio status
    function displayAudioStatus() {
      if (!Tone) {
        messages[clientId] = 'Tone.js not available';
        updateHUD();
        return;
      }
      
      const statusInfo = {
        'Context State': Tone.context.state,
        'Audio Started': audioStarted ? 'Yes' : 'No',
        'Synth Initialized': synth ? 'Yes' : 'No',
        'Sample Rate': Tone.context.sampleRate,
        'Audio Output': meterLevel > 0.01 ? 'Active' : 'Silent',
        'Output Level': (meterLevel * 100).toFixed(1) + '%'
      };
      
      console.table(statusInfo);
      
      let statusMsg = 'Audio Status:\n';
      for (const [key, value] of Object.entries(statusInfo)) {
        statusMsg += `${key}: ${value}\n`;
      }
      
      messages[clientId] = statusMsg;
      updateHUD();
    }
    
    function mousePressed() {
      updatePosition(mouseX, mouseY);
    }
    
    function touchStarted() {
      console.log('touchStarted event fired');
      if (touches.length > 0) {
        updatePosition(touches[0].x, touches[0].y);
      }
      return false; // Prevenir comportamiento por defecto en iOS
    }
    
    function touchMoved() {
      console.log('touchMoved event fired');
      if (touches.length > 0) {
        updatePosition(touches[0].x, touches[0].y);
      }
      return false; // Prevenir comportamiento por defecto en iOS
    }
    
    // sensor handling (for synth only)
    let lastSensorUpdate = 0;
    // Mejorar manejo de eventos de orientación para iOS
    function setupDeviceMotion() {
      console.log('Configurando sensores de movimiento...');
      
      // Manejar diferentes implementaciones de permisos (iOS 13+)
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        console.log('Dispositivo requiere permiso explícito para sensores');
        // iOS 13+ requiere permiso explícito
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') {
              console.log('Permiso de sensores concedido');
              window.addEventListener('deviceorientation', handleDeviceOrientation);
            } else {
              console.log('Permiso de sensores denegado');
              messages[clientId] = 'Se requiere permiso para sensores';
              updateHUD();
            }
          })
          .catch(console.error);
      } else {
        // Dispositivos que no requieren permiso explícito
        window.addEventListener('deviceorientation', handleDeviceOrientation);
      }
    }
    
    // Manejar eventos de orientación
    function handleDeviceOrientation(event) {
      if (!audioStarted) return;
      if (Date.now() - lastSensorUpdate < 100) return;
      lastSensorUpdate = Date.now();
      
      // Verificar que los datos son válidos
      if (event.beta === null || event.gamma === null) {
        console.log('Datos de orientación no disponibles');
        return;
      }
      
      let data = { beta: event.beta, gamma: event.gamma };
      console.log(`Sensor: beta=${data.beta?.toFixed(2)}, gamma=${data.gamma?.toFixed(2)}`);
      
      if (clients[clientId]) {
        socket.emit('sensorData', data);
      }
      
      if (role === 'performer' && synth) {
        let freq = map(data.gamma, -90, 90, 200, 1000);
        synth.set({ oscillator: { frequency: freq } });
        synth.triggerAttackRelease(freq, '8n');
      }
    }
    
    // Iniciar configuración de sensores al cargar
    window.addEventListener('DOMContentLoaded', () => {
      setupDeviceMotion();
    });
    
    // socket.io events
    socket.on('init', (data) => {
      clientId = data.id;
      clientName = data.name || 'performer';
      role = data.role;
      clients = data.clients;
      
      console.log(`init: name=${clientName}, role=${role}, clients=${JSON.stringify(Object.keys(clients))}`);
      
      // Send acknowledgment back to server
      socket.emit('client_ready', { id: clientId, audioReady: audioStarted });
      console.log('Sent client_ready acknowledgment to server');
      
      updateHUD();
    });
    
    socket.on('clientUpdate', (updatedClients) => {
      clients = updatedClients;
      // Always update role from latest server state for this client
      if (clients[clientId] && clients[clientId].role) {
        role = clients[clientId].role;
      }
      console.log('[clientUpdate] clients:', clients, 'role:', role);
      updateHUD();
    });

    // Listen for generator events (sine commands sent to all clients)
    socket.on('generator', (data) => {
      console.log(`[generator] Received event:`, data);
      
      // Send acknowledgment of receipt back to server
      socket.emit('generator_received', { id: clientId, dataType: data.type });
      
      if (data.type === 'sine' || data.type === 's') {
        if (!audioStarted) {
          console.warn('Audio not started. Starting audio context...');
          // Try to start audio context on this event
          Tone.start().then(() => {
            audioStarted = true;
            playGeneratorSound(data);
            // Confirm successful playback
            socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
          }).catch(err => {
            console.error('Failed to auto-start audio:', err);
            // Report failure
            socket.emit('generator_played', { id: clientId, success: false, error: err.message });
          });
        } else {
          playGeneratorSound(data);
          // Confirm successful playback
          socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
        }
      } else if (data.type === 'sf') {
        console.log('SF Generator event received - attempting to process');
        
        // Check if runSfGenerator is available
        if (typeof window.runSfGenerator === 'function') {
          console.log('Using window.runSfGenerator');
          window.runSfGenerator({ ...data, onTrigger: playGeneratorSound });
          socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
        } else if (typeof runSfGenerator === 'function') {
          console.log('Using local runSfGenerator');
          runSfGenerator({ ...data, onTrigger: playGeneratorSound });
          socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
        } else {
          console.error('runSfGenerator function not found! Creating direct sounds instead.');
          
          // Fallback implementation if runSfGenerator isn't available
          const count = data.count || 5;
          const minFreq = data.minFreq || 300;
          const maxFreq = data.maxFreq || 500;
          const dur = data.dur || 1;
          const window = data.window || 10;
          
          for (let i = 0; i < count; i++) {
            setTimeout(() => {
              const freq = minFreq + Math.random() * (maxFreq - minFreq);
              playGeneratorSound({ type: 'sf', freq, dur, vol: data.vol || 9 });
            }, Math.random() * window * 1000);
          }
          
          socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
        }
      }
    });
    
    // Reverb setup
    function createReverb(level) {
      if (!level) return null;
      const reverbTime = Math.max(0.5, level * 0.5); // 0.5s to 4.5s
      const wetLevel = Math.min(0.8, 0.4 + (level / 9) * 0.4);
      
      return new Tone.Reverb({
        decay: reverbTime,
        wet: wetLevel,
        preDelay: 0.01
      });
    }
    
    // Helper function to play generator sounds
    function playGeneratorSound(data) {
      console.log("playGeneratorSound called with:", JSON.stringify(data, null, 2));
      
      // --- Physics: if sine event, assign SineCirclePhysics to this client ---
      if ((data.type === 'sine' || data.type === 'sf') && clients[clientId]) {
        if (!clients[clientId].physics || typeof clients[clientId].physics.trigger !== 'function') {
          clients[clientId].physics = new SineCirclePhysics(clients[clientId].role === 'conductor' ? 50 : 30);
        }
        clients[clientId].physics.trigger(performance.now());
      }

  // Add visual feedback for audio events
  pendingVisualPulses.push(performance.now() + 100); // Add pulse with slight delay

  try {
    let isPoly = data.type === 'sf' || typeof data.vol === 'number';
    console.log(`🎹 Sound type check - isPoly: ${isPoly}, data.type: '${data.type}', has vol: ${typeof data.vol === 'number'}`);
    
    if (isPoly) {
      try {
        // --- Sound generator processing ---
      if (data.generator === 's') {
        try {
          // Choose envelope based on sound type
          let envelope = {};
          if (data.type === 'sf') {
            // SF uses 40% of the duration for fade in/out
            const fadeInTime = 0.4 * data.dur;
            const fadeOutTime = 0.4 * data.dur;
            console.log(`🔈 Creating SF sound: ${fadeInTime}s fade-in, ${fadeOutTime}s fade-out`);
            
            envelope = {
              attack: fadeInTime,
              decay: 0.01,
              sustain: 0.9,
              release: fadeOutTime
            };
          } else {
            // Regular sine wave
            console.log(`🔈 Creating regular sine wave`);
            envelope = {
              attack: 0.01,
              decay: 0.01,
              sustain: 1,
              release: 0.1
            };
          }
          
          // Create the synth with appropriate envelope
          let thisSynth = new Tone.Synth({ envelope }).toDestination();
          
          // Set volume if specified
          if (typeof data.vol === 'number') {
            thisSynth.volume.value = Tone.gainToDb(data.vol / 9);
            console.log(`🔊 Volume: ${data.vol}/9`);
          }
          
          // Apply panning if needed
          if (typeof data.pan === 'number') {
            thisSynth.disconnect();
            const panner = new Tone.Panner(data.pan).toDestination();
            thisSynth.connect(panner);
            console.log(`🔊 Panning: ${data.pan}`);
          }
          
          // Apply reverb if needed
          if (data.reverb) {
            const reverb = createReverb(data.reverb);
            if (reverb) {
              thisSynth.disconnect();
              reverb.toDestination();
              thisSynth.connect(reverb);
              console.log(`🔊 Reverb: level ${data.reverb}/9`);
            }
          }
          
          // Play the sound
          console.log(`🎵 PLAYING: ${data.freq}Hz for ${data.dur}s`);
          thisSynth.triggerAttackRelease(data.freq, data.dur);
          
          // Dispose after appropriate delay
          const extraTime = data.reverb ? (data.reverb * 500) : 0;
          setTimeout(() => {
            thisSynth.dispose();
          }, data.dur * 1000 + 500 + extraTime);
        } catch (err) {
          console.error('Error playing sound:', err);
        }
      }
        messages[clientId] = `sf${data.freq}^${data.dur}`;
        console.log(`[sf] generator event played: ${data.freq}Hz for ${data.dur}s, vol: ${data.vol ?? 'default'}`);
      } catch (err) {
        console.error('Error playing polyphonic sound:', err);
      }
    } else {
      // Monophonic fallback for 's'
      if (!synth) {
        try {
          synth = new Tone.Synth().connect(sweepFilter);
        } catch (err) {
          console.error('Failed to initialize synth:', err);
          return;
        }
      }
      if (typeof data.vol === 'number' && synth.volume) {
        synth.volume.value = Tone.gainToDb(data.vol / 9);
      }
      console.log(`(sine/mono) Reproduciendo: ${data.freq}Hz por ${data.dur}s, vol: ${data.vol ?? 'default'}`);
      synth.triggerAttackRelease(data.freq, data.dur);
      messages[clientId] = `s${data.freq}^${data.dur}`;
      console.log(`[sine] generator event played: ${data.freq}Hz for ${data.dur}s, vol: ${data.vol ?? 'default'}`);
    }

    // Añadir un pulso visual para mostrar que se está reproduciendo el sonido
    document.body.style.boxShadow = 'inset 0 0 20px rgba(0,255,0,0.5)';
    setTimeout(() => {
      document.body.style.boxShadow = 'none';
    }, 100);
  } catch (err) {
        console.error('Error playing sound:', err);
        messages[clientId] = `Error: ${err.message}`;
      }
      updateHUD();
    }
    
    socket.on('control', (data) => {
      if (role === 'performer' && audioStarted) {
        if (data.type === 'freq') {
          if (!synth) synth = new Tone.Synth().connect(sweepFilter);
          synth.set({ oscillator: { frequency: data.value } });
          synth.triggerAttackRelease(data.value, '8n');
          messages[clientId] = `freq ${data.value}`;
        } else if (data.type === 'sine') {
          if (!synth) synth = new Tone.Synth().connect(sweepFilter);
          synth.triggerAttackRelease(data.freq, data.dur);
          messages[clientId] = `s${data.freq}^${data.dur}`;
          console.log(`[sine] Remote: ${data.freq}Hz for ${data.dur}s`);
        }
      }
    });
    
    function sendControl(data) {
      if (role === 'conductor' && audioStarted) {
        socket.emit('conductorControl', data);
      } else if (role === 'performer' && audioStarted) {
        if (data.type === 'sf') {
         // Play sf events for this client
         if (typeof runSfGenerator === 'function') {
           runSfGenerator({ ...data, onTrigger: playGeneratorSound });
         }
         socket.emit('generator_played', { id: clientId, success: true, dataType: data.type });
       } else if (data.type === 'sine') {
          if (!synth) synth = new Tone.Synth().connect(sweepFilter);
          synth.triggerAttackRelease(data.freq, data.dur);
          console.log(`[sine] Local: ${data.freq}Hz for ${data.dur}s`);
        }
      }
    }
    
    function updateHUD() {
  // Always update role from latest server state for this client
  if (clients[clientId] && clients[clientId].role) {
    role = clients[clientId].role;
  }
  // Debug: log all clients
  console.log('[updateHUD] clients:', clients);

  // main HUD (lower-left)
  let hud = `name: ${clientName.toLowerCase()}\n`; 
  hud += `role: ${role ? role.toLowerCase() : 'performer'}\n`; 
      const audioStatus = audioStarted ? 
        (typeof Tone !== 'undefined' && Tone.context ? `on (${Tone.context.state})` : 'on') : 
        'tap "start audio" to begin';
      hud += `audio: ${audioStatus}\n`;
      if (role === 'conductor') {
        hud += `commands: s220 (sine), test, audiostatus\n`;
      }
      if (clients[clientId] && clients[clientId].sensorData) {
        hud += `beta: ${clients[clientId].sensorData.beta?.toFixed(2) || 'n/a'}\n`;
        hud += `gamma: ${clients[clientId].sensorData.gamma?.toFixed(2) || 'n/a'}\n`;
      }
      if (clients[clientId] && clients[clientId].position) {
        hud += `position: ${clientName}/room/${clients[clientId].position.xNorm?.toFixed(2) || '0.50'}/${clients[clientId].position.yNorm?.toFixed(2) || '0.50'}\n`;
      }
      document.getElementById('hud').innerHTML = hud;
      
      // performers HUD (upper-right)
      let performersHud = `performers: ${Object.keys(clients).length}\n`;
      for (let id in clients) {
        let c = clients[id];
        if (!id || !c || !c.name || !c.color || !c.position || typeof c.position.xNorm !== 'number' || typeof c.position.yNorm !== 'number') {
          continue;
        }
        let isConductor = c.role === 'conductor';
        let name = c.name;
        let color = c.color;
        let coords = `x: ${c.position.xNorm.toFixed(2)}, y: ${c.position.yNorm.toFixed(2)}`;
        let msg = messages[id] ? `<span style="color:#fff;opacity:0.8;font-size:13px;">${messages[id]}</span>` : '';
     performersHud += `${isConductor ? '<span style="color:#ff2222;font-weight:bold;margin-right:6px;">C</span> ' : ''}`;
performersHud += `<span style="color: ${color};">${name.toLowerCase()}`;

// Minimalistic sensor feedback (1-9, no labels)
if (c.sensorData) {
  // Map beta [-90,90] to 1-9
  let beta = c.sensorData.beta;
  let betaDigit = (typeof beta === "number")
    ? Math.max(1, Math.min(9, Math.round(((beta + 90) / 180) * 8 + 1)))
    : "";
  // Map gamma [-90,90] to 1-9
  let gamma = c.sensorData.gamma;
  let gammaDigit = (typeof gamma === "number")
    ? Math.max(1, Math.min(9, Math.round(((gamma + 90) / 180) * 8 + 1)))
    : "";
  // Show both, no labels
  performersHud += `<span style="margin-left:4px;font-size:13px;opacity:0.7;">${betaDigit}${gammaDigit}</span>`;
}

performersHud += `</span> <span class="client-data" style="color: ${color}; opacity: 0.3;">${coords}</span> ${msg}\n`;
      }
      document.getElementById('performers-hud').innerHTML = performersHud;
      
      // command prompt for conductor
      let promptDiv = document.getElementById('commandPrompt');
      if (!promptDiv) {
        let input = document.createElement('input');
        input.id = 'commandPrompt';
        input.type = 'text';
        input.placeholder = 'enter command (s200 u10^2)'; // lowercase, already correct
        document.getElementById('hud').appendChild(input);
        document.addEventListener('keydown', function(e) {
          // Only focus prompt if not already in an input/textarea and not with modifiers
          if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
            let prompt = document.getElementById('commandPrompt');
            if (prompt) {
              prompt.focus();
              e.preventDefault();
            }
          }
        });
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            let command = input.value.trim();
            if (command) {
              commandHistory.unshift(command);
              historyIndex = -1;
              evaluateCommand(command);
              input.value = '';
            }
          } else if (e.key === 'ArrowUp') {
            if (historyIndex < commandHistory.length - 1) {
              historyIndex++;
              input.value = commandHistory[historyIndex];
            }
          } else if (e.key === 'ArrowDown') {
            if (historyIndex > -1) {
              historyIndex--;
              input.value = historyIndex === -1 ? '' : commandHistory[historyIndex];
            }
          }
        });
      }
      
      document.getElementById('conductorControls').style.display = audioStarted && role === 'conductor' ? 'block' : 'none';
    }
    
    // Track the last command for macros
    let lastCommand = null;
    
    // --- Keyboard Shortcuts: Ctrl+C and Alt+[1-5] ---
    document.addEventListener('keydown', function(e) {
      // Only trigger if not typing in an input/textarea
      const active = document.activeElement;
      const isInputField = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA');
      
      // Ctrl+C becomes conductor
      if (!isInputField && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
        socket.emit('requestConductor');
        messages[clientId] = 'Requested conductor role (via Ctrl+C)';
        updateHUD();
        e.preventDefault();
        return;
      }
      
      // Handle Alt+number macros for manipulating last command
      if (!isInputField && e.altKey && lastCommand && audioStarted) {
        let newCommand = null;
        
        // Alt+1: Repeat last command exactly
        if (e.key === '1') {
          console.log(`🔁 Repeating last command: ${lastCommand}`);
          newCommand = lastCommand;
        }
        // Alt+2: Play with half duration
        else if (e.key === '2') {
          // Find any duration patterns like ^X and halve the value
          newCommand = lastCommand.replace(/\^(\d+(\.\d+)?)/g, (match, p1) => {
            const halfDuration = parseFloat(p1) / 2;
            return `^${halfDuration}`;
          });
          console.log(`⏱️ Half duration: ${lastCommand} → ${newCommand}`);
        }
        // Alt+3: Play with double duration
        else if (e.key === '3') {
          // Find any duration patterns like ^X and double the value
          newCommand = lastCommand.replace(/\^(\d+(\.\d+)?)/g, (match, p1) => {
            const doubleDuration = parseFloat(p1) * 2;
            return `^${doubleDuration}`;
          });
          console.log(`⏱️ Double duration: ${lastCommand} → ${newCommand}`);
        }
        // Alt+5: Randomize all numeric values
        else if (e.key === '5') {
          // Match all numeric patterns and randomize them
          newCommand = lastCommand.replace(/(\d+)(\.\d+)?/g, (match) => {
            const originalValue = parseFloat(match);
            const randomFactor = 0.5 + Math.random(); // 0.5 to 1.5 range
            return Math.round(originalValue * randomFactor);
          });
          console.log(`🎲 Randomized: ${lastCommand} → ${newCommand}`);
        }
        
        if (newCommand) {
          e.preventDefault();
          evaluateCommand(newCommand);
        }
      }
    });
    // --- Centralized Command Parsing Integration ---
    // Import parseCommand from parsers/commandParser.js at the top of your script:
    // (if using modules)
    // For inlined/legacy, ensure parseCommand is available globally.
    function evaluateCommand(command) {
      if (!command) return;
      
      // Store command for macros
      lastCommand = command;
      
      const trimmedCommand = command.trim();
      console.log(`[command] Evaluating: "${trimmedCommand}"`);

      // Centralized command parsing
      const parsed = parseCommand(trimmedCommand);
      if (parsed) {
        if (parsed.generator === 's') {
          processSineCommand(parsed.freq, parsed.dur);
          return;
        } else if (parsed.generator === 'sf') {
          // Allow any role to send SF commands
          pendingVisualPulses.push(performance.now());
          socket.emit('generator', { type: 'sf', ...parsed, timestamp: Date.now() });
          messages[clientId] = `Sent ${trimmedCommand}`;
          updateHUD();
            
          // Play locally
          if (audioStarted && typeof runSfGenerator === 'function') {
            runSfGenerator({ ...parsed, onTrigger: playGeneratorSound });
          }
          return;
        }
        // Add more generator types here as needed
      }

      // Audio status command
      if (trimmedCommand.toLowerCase() === 'audiostatus') {
        console.log('[command] Checking audio status');
        displayAudioStatus();
        return;
      }

      // Other commands (freq, circle, etc)
      let parts = trimmedCommand.split(' ');
      if (parts[0] === 'freq' && parts[1]) {
        let freq = parseFloat(parts[1]);
        if (!isNaN(freq)) {
          sendControl({ type: 'freq', value: freq });
        }
      } else if (parts[0] === 'circle') {
        let clientIds = Object.keys(clients);
        clientIds.forEach((id, index) => {
          setTimeout(() => {
            if (clients[id].role === 'performer') {
              sendControl({ type: 'freq', value: 200 + (index * 100), target: id });
            }
          }, index * 500);
        });
      } else {
        console.log(`[command] Unknown command: ${trimmedCommand}`);
        messages[clientId] = `Unknown command: ${trimmedCommand}`;
        updateHUD();
      }
    }
    // Helper function to process sine commands
    function processSineCommand(freq, dur) {
      if (role === 'conductor') {
        // Visual feedback that command was received
        pendingVisualPulses.push(performance.now());
        
        // Send to all clients via the server
        socket.emit('generator', { type: 'sine', freq, dur, timestamp: Date.now() });
        console.log(`[sine] Sent sine: ${freq}Hz for ${dur}s to all`);
        messages[clientId] = `Sent s${freq}^${dur} to all clients`;
        updateHUD();
        
        // Also play locally for the conductor
        if (audioStarted) {
          if (!synth) synth = new Tone.Synth().connect(sweepFilter);
          try {
            synth.triggerAttackRelease(freq, dur);
            console.log(`[sine] Conductor local playback: ${freq}Hz for ${dur}s`);
          } catch (err) {
            console.error('Error playing conductor local sound:', err);
          }
        } else {
          console.warn('Audio not started for conductor');
          // Try to start audio
          Tone.start().then(() => {
            audioStarted = true;
            if (!synth) synth = new Tone.Synth().connect(sweepFilter);
            synth.triggerAttackRelease(freq, dur);
            console.log('Started audio and played sound');
            updateHUD();
          }).catch(err => console.error('Failed to start audio:', err));
        }
      } else {
        console.log(`[command] Not a conductor, can't broadcast commands`);
      }
    }
    

    

    // error boundary
    window.onerror = function(msg, url, lineNo, columnNo, error) {
      console.log(`error: ${msg} at ${url}:${lineNo}`);
        return false;
      };
    // Ensure all script blocks are closed
    </script>

    <script>
/* ==== Sweep Filter Controlled by Device Rotation ==== */

// --- Config ---
const minFreq = 200, maxFreq = 2000; // Filter sweep range (Hz)
let sensorsEnabled = false;

// --- Create a filter and connect to master output ---
const sweepFilter = new Tone.Filter(minFreq, "lowpass").toDestination();

// --- HUD for debugging ---
const hud = document.createElement("div");
Object.assign(hud.style, {
  position: "fixed", top: "10px", left: "10px",
  color: "lightgray", fontSize: "1.1em", fontFamily: "monospace",
  background: "rgba(0, 0, 0, 0.5)", padding: "5px 10px", borderRadius: "5px",
  zIndex: "1000", pointerEvents: "none"
});
document.body.appendChild(hud);

// --- Permission Request ---
async function requestSensorPermissions() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    try {
      const permissionState = await DeviceMotionEvent.requestPermission();
      if (permissionState === "granted") sensorsEnabled = true;
      else console.error("Sensor access denied");
    } catch (e) { console.error("Sensor permission error", e); }
  } else {
    sensorsEnabled = true;
  }
  await Tone.start();
  console.log("AudioContext started, sensorsEnabled:", sensorsEnabled);
}

// --- Orientation Handler ---
let rotX = 0, rotY = 0, rotZ = 0, initialBeta = null;
function orientationHandler(event) {
  if (!sensorsEnabled) return;
  // Use beta (front-back tilt) for sweep
  if (initialBeta === null) initialBeta = event.beta || 0;
  rotX = event.beta || 0;
  rotY = event.gamma || 0;
  rotZ = event.alpha || 0;
  // Map beta (rotX) from initialBeta±45° to minFreq-maxFreq
  let sweep = Math.max(-45, Math.min(45, rotX - initialBeta));
  let freq = minFreq + ((sweep + 45) / 90) * (maxFreq - minFreq);
  sweepFilter.frequency.rampTo(freq, 0.1);
  // HUD
  hud.innerHTML = `rotX (beta): ${rotX.toFixed(1)}<br>Filter freq: ${freq.toFixed(1)} Hz`;
}

// --- Enable on user gesture ---
document.body.addEventListener("touchend", async () => {
  if (!sensorsEnabled) {
    await requestSensorPermissions();
    if (sensorsEnabled) {
      window.addEventListener("deviceorientation", orientationHandler, false);
      console.log("Sweep filter sensor control enabled!");
    }
  }
});
// Also allow desktop click for testing
document.body.addEventListener("click", async () => {
  if (!sensorsEnabled) {
    await requestSensorPermissions();
    if (sensorsEnabled) {
      window.addEventListener("deviceorientation", orientationHandler, false);
      console.log("Sweep filter sensor control enabled!");
    }
  }
});
</script>
  </body>
</html>